<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-暑期总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/03/暑期总结/" class="article-date">
  <time datetime="2019-09-03T05:20:13.000Z" itemprop="datePublished">2019-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/03/暑期总结/">暑期总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="第一个月"><a href="#第一个月" class="headerlink" title="第一个月"></a>第一个月</h4><h5 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h5><p>暑假第一个月学的东西还挺杂的。</p>
<p>前两个星期学了JS高程设计前七章内容，ES6部分章节，一点点JQ，一点node.js，git合作相关知识。</p>
<p>后面一个星期就是做我们自己的一个练手小项目菠萝，但是感觉没有怎么锻炼到团队合作能力，而且也没有后台hhh。</p>
<h5 id="珠海游"><a href="#珠海游" class="headerlink" title="珠海游"></a>珠海游</h5><p>八月初暑假培训结束后，大家伙们就一起去了珠海玩，不得不吐槽一下那个别墅的环境是真的很糟糕。可惜的是那两天都有点失眠，神情恍惚，看鬼片的时候差点睡着了哈哈哈哈。</p>
<p>总而言之，虽然有点小小的遗憾，但是大家一起玩耍，还是很开心，很美好的回忆啦~</p>
<h4 id="第二个月"><a href="#第二个月" class="headerlink" title="第二个月"></a>第二个月</h4><ul>
<li>回家后就和朋友去了一个岛上玩，可惜那时候还没出海，不然可以体验一下捕鱼的快乐嘿嘿嘿。本来想看日出的，结果跑到了西边的海（蠢蛋）</li>
<li>回家没多久，就和朋友们去ktv玩到凌晨一点多，从此开始了在家里的熬夜时光。。。</li>
</ul>
<p>后面几乎每天晚上都和朋友出去吃烧烤，被家里人疯狂投喂，导致脸越来越圆，越来越圆……黑眼圈越来越重，越来越重……..哭了ORZ</p>
<p>本来想在家里能够学一下vue.js的，结果每天都在浪，没怎么学习，只能开学的时候学了QAQ。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/03/暑期总结/" data-id="ck087s6hh000diwvcxhu7yhcg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day14" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/day14/" class="article-date">
  <time datetime="2019-07-24T14:09:03.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/day14/">day14</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#### </p>
<h5 id="页面字数变多时，字体会变大"><a href="#页面字数变多时，字体会变大" class="headerlink" title="页面字数变多时，字体会变大"></a>页面字数变多时，字体会变大</h5><ul>
<li>原因：暂不明确</li>
<li>解决方法：<ul>
<li>可以设置<code>max-height:9999px</code>解决该问题。</li>
<li>可以给内容的父元素或者祖先元素设置高度。</li>
</ul>
</li>
</ul>
<h5 id="xd里字间距与网页中怎么进行转换"><a href="#xd里字间距与网页中怎么进行转换" class="headerlink" title="xd里字间距与网页中怎么进行转换"></a>xd里字间距与网页中怎么进行转换</h5><ul>
<li>real_letter_spacing = font * 10 / spacing</li>
</ul>
<p>##### </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/day14/" data-id="ck087s6h70005iwvcwuaoxohz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/day13/" class="article-date">
  <time datetime="2019-07-23T01:08:59.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/day13/">day13</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h4><ul>
<li><p>获得当前索引号 <code>$(this).index()</code></p>
</li>
<li><ul>
<li>添加类 <code>addClass()</code> 追加类名，不影响原来的类名。</li>
<li>删除类<code>removeClass()</code></li>
<li>切换类<code>toggleClass()</code> 如果有该类名，就删去，如果没有，就加上。</li>
</ul>
</li>
<li><p>动画效果</p>
<ul>
<li><p>显示隐藏（一般情况下不加参数）</p>
<ul>
<li>show([speed],[easing],[fn])</li>
<li>hide([speed],[easing],[fn])</li>
<li>toggle([speed],[easing],[fn])</li>
</ul>
</li>
<li><p>滑动效果(显示隐藏)</p>
<ul>
<li>slideDown()：下滑动</li>
<li>slideUp()：上滑动</li>
<li>slideToggle()：滑动切换 </li>
</ul>
</li>
<li><p>事件切换</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//鼠标经过的函数</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//鼠标离开的离开的函数</span></span><br><span class="line">    <span class="comment">//如果只写一个函数，鼠标离开或经过都会触发那个函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>动画或者效果一旦触发就会执行，如果多次触发，就会造成多个动画或者效果排队执行。</p>
<ul>
<li>stop()；//必须写在动画的前面，停止动画排序。</li>
</ul>
</li>
<li><p>淡入淡出效果</p>
<ul>
<li>fadeIn()    //淡入效果</li>
<li>fadeOut()   //淡出效果</li>
<li>fadeToggle()  //切换</li>
<li>fadeTo()  //修改透明度 透明度参数一定要写</li>
</ul>
</li>
<li><p>自定义动画 animate</p>
<ul>
<li>animate(params,[speed],[easing],[fn])</li>
<li>params：想要更改的样式属性，以对象形式传递，必须写。属性名可以不用带引号，如果是复合属性则需要采取驼峰命名法，其余参数都可以省略。</li>
</ul>
</li>
</ul>
</li>
<li><p>属性操作</p>
<ul>
<li><p>获取元素固有属性</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop(<span class="string">"属性名"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>设置属性</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop(<span class="string">"属性名"</span>,<span class="string">"属性值"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>获取元素自定义属性</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attr(<span class="string">"属性名"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attr(<span class="string">"属性名"</span>,<span class="string">"属性值"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数据缓存date() </p>
<ul>
<li>date()方法可以在指定的元素上存取数据，并不会修改DOM元素结构，一旦页面刷新，之前存放的数据都被移除。</li>
</ul>
</li>
</ul>
</li>
<li><p>添加html内容</p>
<ul>
<li>append() - 在被选元素的结尾插入内容</li>
<li>prepend() - 在被选元素的开头插入内容</li>
<li>after() - 在被选元素之后插入内容</li>
<li>before() - 在被选元素之前插入内容</li>
</ul>
</li>
<li><p>删除元素/内容</p>
<ul>
<li>remove() - 删除被选元素（及其子元素），可接受一个参数，允许您对被删元素进行过滤。</li>
<li>empty() - 从被选元素中删除子元素</li>
</ul>
</li>
<li><p>width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。</p>
<p>height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。</p>
<p>innerWidth() 方法返回元素的宽度（包括内边距）。</p>
<p>innerHeight() 方法返回元素的高度（包括内边距）。</p>
<p>outerWidth() 方法返回元素的宽度（包括内边距和边框）。</p>
<p>outerHeight() 方法返回元素的高度（包括内边距和边框）。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/23/day13/" data-id="ck087s6h50002iwvc6th9vfgy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day12" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/20/day12/" class="article-date">
  <time datetime="2019-07-20T11:48:02.000Z" itemprop="datePublished">2019-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/20/day12/">day12</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h4><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><ul>
<li>类似于数组，但是成员的值都是唯一的，没有重复的值。</li>
<li>向set加入值的时候，不会发生类型转换。</li>
<li>判断两个值是否不同，使用的算法类似于（===），主要区别是set认为NaN等于自身，而精确相等运算符认为NaN不等于自身。</li>
<li>两个对象总是不相等，空对象也不相等。</li>
<li><code>Array.from</code>方法可以将 Set 结构转为数组。</li>
<li>Set结构键值和键名是同一个值。</li>
<li>方法<ul>
<li>add()</li>
<li>delete()</li>
<li>clear()</li>
</ul>
</li>
</ul>
<h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><ul>
<li>weakSet结构与Set类似，也是不重复的值的集合，但是与Set有两个区别。WeakSet的成员只能是对象，而不能是其他类型的值。</li>
</ul>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul>
<li>js的对象，本质上是键值对的集合，但是传统上只能用字符串当作键。</li>
<li>object结构提供“字符串——值”的对应，Map结构提供“值——值”的对应（各种类型的值（包括对象）都可以当作键）。</li>
<li>如果对同一个键多次赋值，后面的值将覆盖前面的值。</li>
<li>方法：<ul>
<li>set(key,value)</li>
<li>get(key);</li>
<li>delete(key)</li>
<li>clear()</li>
<li>has(key)</li>
</ul>
</li>
<li>如果Map的键是一个简单类型的值（数字，字符串，布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0.另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。</li>
</ul>
<h4 id="Promise协议"><a href="#Promise协议" class="headerlink" title="Promise协议"></a>Promise协议</h4><ul>
<li><p>Promise，就是一个容器，里面保存着某个未来才会结束的时间的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。</p>
</li>
<li><p>对象的状态不受外界影响。</p>
<ul>
<li>pending：进行中</li>
<li>fulfilled：已成功</li>
<li>rejected：已失败</li>
</ul>
</li>
<li><ul>
<li><p>Promise.all() ：所有请求都成功了才使用resolve。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([$.ajax(&#123;<span class="attr">url</span>:<span class="string">""</span>&#125;,<span class="attr">dataType</span>:<span class="string">'json'</span>),</span><br><span class="line">             $.ajax(&#123;<span class="attr">url</span>:<span class="string">""</span>&#125;,<span class="attr">dataType</span>:<span class="string">'json'</span>),</span><br><span class="line">             $.ajax(&#123;<span class="attr">url</span>:<span class="string">""</span>&#125;,<span class="attr">dataType</span>:<span class="string">'json'</span>),</span><br><span class="line">            ]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line"><span class="comment">//只有所有请求都成功了，才会使用第一个function。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li>Promise.race：</li>
</ul>
<h4 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h4><ul>
<li><p>普通函数——一条路走到底 中就不会停</p>
</li>
<li><p>generator函数——中间可以暂停</p>
</li>
<li><p>yield</p>
<ul>
<li><p>可以传参，可以返回</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">传参</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span>;</span><br><span class="line">    </span><br><span class="line">    alert(<span class="string">'b'</span>);</span><br><span class="line">    alert(a);<span class="comment">//5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = show();</span><br><span class="line">gen.next(<span class="number">12</span>);<span class="comment">//第一个传参无用</span></span><br><span class="line">gen.next(<span class="number">5</span>);<span class="comment">//参数传到yeied</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回</p>
</li>
</ul>
</li>
</ul>
<h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p><code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></p>
<ul>
<li><code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li>
<li><code>async</code>函数的返回值是 Promise 对象，可以用<code>then</code>方法指定下一步的操作。</li>
</ul>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><ul>
<li>类的所有方法都定义在类的<code>prototype</code>属性上面。</li>
<li>类的内部所有定义的方法，都是不可枚举的。</li>
<li>类必须使用<code>new</code>调用，否则会报错。</li>
<li>实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</li>
<li>类不存在变量提升。</li>
<li>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，如果方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境。</li>
<li>如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</li>
<li>父类的静态方法，可以被子类继承。</li>
<li>Class 可以通过<code>extends</code>关键字实现继承。</li>
</ul>
<h4 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h4><ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">页面加载完后再执行该代码</span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>相当于原生js中的DOMContentLoaded</li>
<li>不同于原生种的load事件（等页面文档，外部js文件，css文件，图片加载完毕才执行内部代码）。</li>
</ul>
</li>
<li><p>原生js获取的对象是DOM对象，用jQuery获取的对象是jQuery对象。</p>
</li>
<li><p>jQuery对象只能使用jQuery 方法，DOM对象则使用原生的JavaScript属性和方法。</p>
</li>
<li><p>jQuery对象转成DOM对象</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>)[index];</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).get(index);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>隐形迭代</p>
<ul>
<li>给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化操作，方便调用。</li>
</ul>
</li>
<li><p>筛选选择器</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:eq(index);<span class="comment">//索引为index的元素，索引号从0开始。</span></span><br><span class="line">:odd<span class="comment">//索引为奇数的元素。</span></span><br><span class="line">:even<span class="comment">//索引号为偶数的元素。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/20/day12/" data-id="ck087s6h30001iwvck5kcchxq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/day11/" class="article-date">
  <time datetime="2019-07-18T12:53:29.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/day11/">day11</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li><p>使用默认值传值</p>
<ul>
<li>参数默认值不是传值的，而是每次都重新计算默认值表达式的值，也就是说，参数默认值是惰性求值。</li>
</ul>
</li>
<li><p>可以与解构赋值默认值结合使用</p>
<ul>
<li><p>如果没有提供参数，函数参数默认为一个空对象（按下列的写法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x,y=<span class="number">5</span>&#125;=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line">foo()<span class="comment">//undefined 5</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// "GET"</span></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) </span>&#123; <span class="comment">//代码指定，如果没有提供第二个参数，就默认第二个参数为空对象。如果是一个对象，就可以为他的三个属性设置默认值。</span></span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line"><span class="comment">// "GET"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>函数的length属性</p>
<ul>
<li>指定了默认值后，函数的length属性将返回没有指定默认值的参数个数，也就是说，指定了默认值后，length属性将失真。</li>
<li>length含义是，该函数预期传入的参数个数，某个参数指定默认值后，预期传入的参数个数就不包括这个参数了。</li>
<li>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域，等到初始化结束，这个作用域会消失，这种语法行为，在不设置参数默认值时是不会出现的。</li>
</ul>
</li>
</ul>
<h5 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h5><ul>
<li>形式为 …变量名 ，用于获取函数的多余参数。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</li>
<li>rest参数之后不能再有其他参数，否则会报错。</li>
<li>注意：函数的length属性，不包括rest</li>
</ul>
<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><ul>
<li><p>允许使用“箭头” =&gt; 定义函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不需要参数或者需要多个参数，就用一个圆括号代替参数部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span><span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> num1+num2;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于大括号会被解释成代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会出错。</p>
</li>
<li><p>函数体内的<code>this</code>对象，总是指向函数定义生效时所在的对象，而不是使用时所在的对象。</p>
</li>
<li><p>箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向。</p>
</li>
</ul>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><ul>
<li>对象的属性名可以有两种类型，一种是原来就有的字符串，另一种就是新增的symbol类型，凡是属性名属于symbol类型，就都是独一无二的，可以保证与其他属性名产生冲突。</li>
<li>Symbol 值不是对象，所以不能添加属性。不可以使用new命令。</li>
<li><a href="https://github.com/tc39/proposal-Symbol-description" target="_blank" rel="noopener">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</li>
<li>Symbol 值作为对象属性名时，不能用点运算符。</li>
<li>symbol作为属性名，该属性不会出现在for..in、for..of循环中，也不会被object.keys()等返回，但是，它不是私有属性，有一个object.getOwnPropertySymbols方法，可以获取指定对象的所有symbol属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的symbol值。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/18/day11/" data-id="ck087s6h60003iwvch6t7qkww" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/day10/" class="article-date">
  <time datetime="2019-07-17T14:10:00.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/day10/">day10</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1</p>
<h4 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h4><ul>
<li>for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</li>
<li>ES6的块级作用域必须有大括号，如果没有大括号，JavaScript引擎就不存在块级作用域。</li>
</ul>
<h5 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h5><ul>
<li><p>var 命令有变量提升现象，变量可以在声明之前使用，值为undefined。let命令改变了语法行为，他所声明的变量必须在声明后才可以使用，否则报错。</p>
</li>
<li><p>暂时性死区：只要在块级作用域内存在let命令，他所声明的变量就绑定这个区域，不受外部的影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    tmp=<span class="string">"abc"</span>;<span class="comment">//Error</span></span><br><span class="line">    <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在块级作用域内let声明了一个局部变量，绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>
</li>
</ul>
<h5 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h5><ul>
<li>const表明一个只读的常量，一旦声明，常量的值就不能改变。这也意味着一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
<li>const声明的常量只在声明的块级作用域内有效。</li>
<li>const命令声明的常量不提升，存在暂时性死区。</li>
<li>不可重复声明。</li>
<li>const保证的是变量指向的那个内存地址所保存的数据不可改变。对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的那个内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，这个指针指向的数据是不是可变的，就完全不可控制了。</li>
</ul>
<h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h4><h5 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h5><ul>
<li><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码表示从数组中提取值，按照对应位置，对变量赋值。</span></span><br><span class="line"><span class="comment">本质上，这种写法属于“模型匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果解构不成功，变量的值就等于undefined</p>
</li>
</ul>
<h6 id="默认值（数组）"><a href="#默认值（数组）" class="headerlink" title="默认值（数组）"></a>默认值（数组）</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>[foo = <span class="literal">true</span>]=[]</span><br><span class="line">foo<span class="comment">//true;</span></span><br><span class="line"><span class="keyword">let</span>[x,y=<span class="string">'b'</span>] = [<span class="string">'a'</span>]<span class="comment">//x='a',y='b';</span></span><br><span class="line"><span class="keyword">let</span>[x,y=<span class="string">'b'</span>]=[<span class="string">'a'</span>,undefiend];<span class="comment">//x='a',y='b';</span></span><br><span class="line"><span class="comment">//只有一个数组成员严格等于undefined，默认值才会生效</span></span><br><span class="line"><span class="keyword">let</span>[x=<span class="number">1</span>]=[<span class="literal">null</span>]<span class="comment">//x=null null不严格等于undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果默认值是一个表达式，那么这个表达式是惰性求值，只有在用到的时候，才会求值。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x=f()] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">//此时，因为x能取到值，所以f不会被执行。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h5><ul>
<li><p>解构不仅可以用于数组，还可以用于对象。</p>
</li>
<li><p>对象的结构与数组有一个重要的不同，数组的元素是按次序排序的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须和属性同名，才能去到正确的值。</p>
</li>
<li><p>如果变量名和属性名不一样，写成下面那样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>:baz&#125; = &#123;<span class="attr">foo</span>:<span class="string">"aaa"</span>,<span class="attr">bar</span>:<span class="string">"bbb"</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(baz);<span class="comment">//"aaa"</span></span><br><span class="line"><span class="comment">//对象解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h6><ul>
<li>默认值生效的条件是，对象的属性值严格等于undefined。</li>
</ul>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//上面代码的写法会报错，因为JavaScript引擎会把&#123;x&#125;理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;);<span class="comment">//这样才正确。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/17/day10/" data-id="ck087s6h60004iwvcs80x3ied" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/day9/" class="article-date">
  <time datetime="2019-07-17T01:07:22.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/day9/">day9</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="vw和vh"><a href="#vw和vh" class="headerlink" title="vw和vh"></a>vw和vh</h4><p>vw是可视窗口的宽度单位，1vw = 可视窗口的百分之一。与百分比不一样的是，vw始终相对于可视窗口的宽度，而百分比和父元素的宽度有关。</p>
<p>vh则是可视窗口的高度。</p>
<p>vmin：选择vw和vh最小的那个</p>
<p>vmax：选择最大的那个。</p>
<h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>1、touch：移动端的触摸，是一组事件。</p>
<ul>
<li>e.touches[0]：第一个触摸点</li>
<li>clientX clientY ：基于浏览器窗口</li>
<li>pageX pageY ：基于页面</li>
<li>screenX screenY：基于屏幕</li>
</ul>
<p>2、touchstart：当触摸屏幕的时候触发。</p>
<p>3、touchend：当手指离开屏幕的时候触发。</p>
<p>4、touchmove：手指在屏幕中来回滑动触发。</p>
<p>5、touchcancel：被迫中止手势滑动的时候触发。</p>
<p>以上对象都有以下的属性：</p>
<ul>
<li>touchList：触摸点的集合。<ul>
<li>触摸点：一个手指就是一个出发点，和屏幕接触点的个数。</li>
</ul>
</li>
<li>changedTouches：改变后的触摸点的集合。</li>
<li>targetTouches：当前元素的触发点的集合。</li>
<li>touches：页面上所有触发点的集合。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/17/day9/" data-id="ck087s6hc000aiwvcxibm9zxp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/day8/" class="article-date">
  <time datetime="2019-07-16T01:08:06.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/day8/">day8</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"150"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>canvas标签只有两个属性，width和height，这些都是可选的。但没有设置宽度和高度时，canvas会初始化宽度为300像素和高度为150像素。该元素可以使用css来定义大小，但是在绘制图形时会伸缩以适应它的框架尺寸，如果css尺寸与初始画布比例不一致，它会出现扭曲。</p>
<h5 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h5><p>canvas起初是空白的，为了展示，首先脚本需要找到渲染上下文，然后在它上面绘制。</p>
<p>canvas元素有getContext()方法，这个方法是用来获得渲染上下文和它的绘画功能。getContext()只有一个参数，上下文的格式。</p>
<h5 id="创建矩形"><a href="#创建矩形" class="headerlink" title="创建矩形"></a>创建矩形</h5><ul>
<li>ctx.fillRect(x,y,width,height)：绘制一个填充矩形<ul>
<li>x：矩形起始点的x轴坐标</li>
<li>y：矩形起始点y轴的坐标</li>
<li>width：矩形的宽度</li>
<li>height：矩形的高度</li>
</ul>
</li>
<li>ctx.strokeRect(x,,y,width,height)：绘制一个描边矩形<ul>
<li>width:矩形的宽度，正值在右侧，负值在左侧。</li>
<li>height：矩形的高度。正直在下，负值在上。</li>
</ul>
</li>
<li>clearRect(x,y,width,height)：清除指定矩形区域，让清除部分完全透明。</li>
</ul>
<h5 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h5><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。</p>
<p>利用路径绘制图形需要一些额外的步骤</p>
<ul>
<li>创建路径起始点</li>
<li>使用画图命令去画路径</li>
<li>把路径封闭</li>
<li>一旦路径生成，就可以通过秒表或填充路径区域来渲染图形。</li>
</ul>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><ul>
<li>beginPath()：新建一条路径，生成之后，图形绘制命令被指到路径上生成路径。</li>
<li>closePath()：闭合路径之后图形绘制命令又重新指向到上下文中。</li>
<li>stroke()：通过线条来绘制图形轮廓</li>
<li>fill()：通过填充路径的内容区域来生成实心的图形。<ul>
<li>调用该函数时，没有闭合的路径会自动闭合，但是调用stroke函数不会。</li>
</ul>
</li>
<li>moveTo(x,y)：将笔触移动到指定的坐标x和y上。</li>
<li><code>arc(100,75,50,0*Math.PI,1.5*Math.PI，false)</code><ul>
<li>圆的中心(100,75)</li>
<li>起始角：0</li>
<li>圆的半径：50</li>
<li>结束角：1.5*Math.PI</li>
<li>默认为顺时针</li>
<li>false：顺时针 true：逆时针</li>
</ul>
</li>
<li>lineTo(x,y)：绘制一条从当前位置到指定x以及y位置的直线。</li>
</ul>
<h5 id="二次贝塞尔曲线及三次贝塞尔曲线"><a href="#二次贝塞尔曲线及三次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线及三次贝塞尔曲线"></a>二次贝塞尔曲线及三次贝塞尔曲线</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quadraticCurveTo(cp1x, cp1y, x, y)</span><br></pre></td></tr></table></figure>

<p>绘制二次贝塞尔曲线，<code>cp1x,cp1y</code>为一个控制点，<code>x,y为</code>结束点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</span><br></pre></td></tr></table></figure>

<p>绘制三次贝塞尔曲线，<code>cp1x,cp1y</code>为控制点一，<code>cp2x,cp2y</code>为控制点二，<code>x,y</code>为结束点。</p>
<h5 id="Path2D对象"><a href="#Path2D对象" class="headerlink" title="Path2D对象"></a>Path2D对象</h5><p>Path2D会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Path2D()<span class="comment">//空的path对象</span></span><br><span class="line"><span class="keyword">new</span> Path2D(path)<span class="comment">//克隆path对象</span></span><br><span class="line"><span class="keyword">new</span> Path2D(d) <span class="comment">//从svg建立path对象</span></span><br></pre></td></tr></table></figure>

<p>Path2D添加了 addPath 作为将Path结合起来的方法。</p>
<h5 id="添加颜色"><a href="#添加颜色" class="headerlink" title="添加颜色"></a>添加颜色</h5><p>fillStyle = color ：设置图形的填充颜色</p>
<p>strokeStyle = color ：设置图形轮廓的颜色</p>
<p>注意：一旦设置了strokeStyle或者fillStyle的值，那么这个新值就会成为新绘制的图形的默认值。如果要给每个图形上不同的颜色，就需要重新设置fillStyle或strokeStyle的值。</p>
<h5 id="lineStyle"><a href="#lineStyle" class="headerlink" title="lineStyle"></a>lineStyle</h5><h6 id="1、lineWdith：设置线条宽度"><a href="#1、lineWdith：设置线条宽度" class="headerlink" title="1、lineWdith：设置线条宽度"></a>1、lineWdith：设置线条宽度</h6><p>注意：注意奇偶数时在画布上的渲染。</p>
<h6 id="2、lineCap属性：线段端点显示的样子"><a href="#2、lineCap属性：线段端点显示的样子" class="headerlink" title="2、lineCap属性：线段端点显示的样子"></a>2、lineCap属性：线段端点显示的样子</h6><ul>
<li>butt：默认值，与辅助线齐平。</li>
<li>round：端点处加上了半径为一半线段的半圆。</li>
<li>square：加上了等宽且高度为一般线宽的方块。</li>
</ul>
<h6 id="3、lineJoin：图形中两线段连接处所显示的样子。"><a href="#3、lineJoin：图形中两线段连接处所显示的样子。" class="headerlink" title="3、lineJoin：图形中两线段连接处所显示的样子。"></a>3、lineJoin：图形中两线段连接处所显示的样子。</h6><ul>
<li>round：边角处背磨圆，圆的半径等于线宽</li>
<li>bevel：</li>
<li>miter：默认值，线段会在连接处外侧延伸直至交于一点。</li>
</ul>
<h4 id="动画的基本步骤"><a href="#动画的基本步骤" class="headerlink" title="动画的基本步骤"></a>动画的基本步骤</h4><h6 id="1、清空canvas"><a href="#1、清空canvas" class="headerlink" title="1、清空canvas"></a>1、清空canvas</h6><p>除非接下来要画的内容会充满canvas（例如背景图），否则需要清空所有，最简单的做法是用clearRect()方法</p>
<h6 id="2、保存canvas状态"><a href="#2、保存canvas状态" class="headerlink" title="2、保存canvas状态"></a>2、保存canvas状态</h6><p>如果要改变canvas状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，需要保存。</p>
<h6 id="3、绘制动画图形"><a href="#3、绘制动画图形" class="headerlink" title="3、绘制动画图形"></a>3、绘制动画图形</h6><h6 id="4、恢复canvas状态"><a href="#4、恢复canvas状态" class="headerlink" title="4、恢复canvas状态"></a>4、恢复canvas状态</h6><p>如果保存了canvas状态，可以先恢复它，然后重绘下一帧。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p>rotate()</p>
<ul>
<li>参数：以弧度制</li>
<li>旋转中心在整个画布的左上角，旋转的正方向是顺时针，反方向是逆时针。</li>
<li>canvas中rotate方法是绕画布左上角（0，0）进行旋转的，而且会受到translate影响。</li>
</ul>
</li>
<li><p>save()</p>
<ul>
<li>当前的变换矩阵</li>
<li>当前的剪切区域</li>
<li>当前的虚线列表</li>
<li>一些属性当前的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">ctx.save();<span class="comment">//保存默认的状态</span></span><br><span class="line">ctx.fillStyle = <span class="string">" "</span>;</span><br><span class="line">......</span><br><span class="line">ctx.restore();<span class="comment">//还原到上次保存的默认状态</span></span><br></pre></td></tr></table></figure>

<p>每调用一次restore方法，上一次保存的状态就从栈中弹出，所有设定都恢复。</p>
</li>
<li><p>translate</p>
<ul>
<li>移动canvas原点</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/day8/" data-id="ck087s6hf000biwvcjyv0l25c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/15/day7/" class="article-date">
  <time datetime="2019-07-15T01:06:13.000Z" itemprop="datePublished">2019-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/15/day7/">day7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="作用域的控制机制"><a href="#作用域的控制机制" class="headerlink" title="作用域的控制机制"></a>作用域的控制机制</h4><p>1、每个函数都有各自的作用域，作用域链，变量对象，执行环境。</p>
<p>其中，作用域链在函数初始化完成后便存在，而作用域，变量对象，执行环境只有在函数执行时才创建。</p>
<p>执行结束后，<strong>函数的作用域，作用域链，执行环境被销毁</strong>，而变量对象仍可能留在内存中。（如果函数内部有闭包，则函数执行结束后，变量对象仍然留在内存，知道闭包执行结束，该变量对象才会被销毁。）</p>
<p>2、作用域链</p>
<ul>
<li>把多个作用域串起来便形成了作用域链</li>
<li>每个函数在初始化完成后就拥有了各自的作用域链，但此时作用域链中并不包含自己的作用域，只有函数执行时，才会创建自己的作用域，并加在作用域的开头。</li>
<li>作用域链中不仅存储了函数本身的作用域，还存储了该函数能够访问的其他函数的作用域。</li>
</ul>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>1、概念：闭包是函数和引用环境组成的整体。环境包含了这个闭包创建时所能访问的所有局部变量。</p>
<p>函数是一些可执行代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的环境组合可以产生不同的实例。</p>
<p>2、作用：</p>
<ul>
<li>可以在函数的外部访问到函数内部的局部变量。</li>
<li>让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</li>
</ul>
<p>3、函数表达式声明方式并且声明后加上了()，所以会自动执行一次。</p>
<p><a href="https://blog.csdn.net/u010425776/article/details/53557942" target="_blank" rel="noopener">1</a></p>
<p><a href="https://blog.csdn.net/u010425776/article/details/53617292" target="_blank" rel="noopener">2</a></p>
<p><a href="https://blog.csdn.net/u010425776/article/details/53704179" target="_blank" rel="noopener">3</a></p>
<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p>Ajax是一种无需重新加载整个网页的情况下，能够更新部分网页的技术。</p>
<h6 id="1、XMLHttpRequest对象"><a href="#1、XMLHttpRequest对象" class="headerlink" title="1、XMLHttpRequest对象"></a>1、XMLHttpRequest对象</h6><p>Ajax核心是XMLHttpRequest对象（XHR），XHR向服务器发送请求和解析服务器响应提供了接口，能够以异步方式从服务器获取新数据。</p>
<p>XHR的主要属性：</p>
<ul>
<li>Number readyState 状态值<ul>
<li>0：未初始化。未调用open()方法。</li>
<li>1：启动。已经调用open()方法，为调用send()方法。</li>
<li>2：发送。已经调用send()方法，为接受到响应。</li>
<li>3：接受。已经接受到部分数据。</li>
<li>4：完成。已经接受到全部数据，可以在客户端使用。</li>
</ul>
</li>
<li>向服务器发送请求，使用XMR对象的open和send方法。<ul>
<li>open(method,url,async)<ul>
<li>method：请求的类型，get或者post</li>
<li>url：文件在服务器上的位置</li>
<li>async：true（异步）或false（同步）</li>
</ul>
</li>
<li>send(string)：将请求发送到服务器。<ul>
<li>string：仅用于post请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="2、Get请求"><a href="#2、Get请求" class="headerlink" title="2、Get请求"></a>2、Get请求</h6><p>Get用于向服务器查询某些信息</p>
<h6 id="3、post请求"><a href="#3、post请求" class="headerlink" title="3、post请求"></a>3、post请求</h6><p>post请求用于向服务器发送应该被保存的数据。post请求的主体可以包含非常多的数据，而且格式不限。</p>
<p>注意：在一下情况下，使用post请求</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（post没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，post比get更稳定可靠。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/15/day7/" data-id="ck087s6hg000ciwvcdv9lbyhh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/day6/" class="article-date">
  <time datetime="2019-07-14T01:02:34.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/14/day6/">day6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="1、JS中new一个对象的过程"><a href="#1、JS中new一个对象的过程" class="headerlink" title="1、JS中new一个对象的过程"></a>1、JS中new一个对象的过程</h5><p>var obj = new ClassA();</p>
<p>1、创建空对象；</p>
<p>var obj = {};</p>
<p>2、设置新对象的constructor属性为构造函数的名称，设置新对象的<code>__proto__</code>属性指向构造函数的prototype对象</p>
<p><code>obj.__proto__ = ClassA.prototype</code>;</p>
<p>3、使用新对象调用函数，函数中this被指向新实例对象</p>
<p>ClassA.call(obj);</p>
<p>4、将初始化完毕的新对象地址，保存到等号左边的变量中。</p>
<h5 id="2、关于原型一些总结"><a href="#2、关于原型一些总结" class="headerlink" title="2、关于原型一些总结"></a>2、关于原型一些总结</h5><p>1、原型属性中若有引用值类型，对实例进行修改，原型中该数值也会被修改。</p>
<p>而基本类型值不会被修改。</p>
<p>2、每个函数都有一个prototype属性，这个属性指向一个对象，这个对象我们叫做原型对象。</p>
<p>3、</p>
<ul>
<li>每个对象都有一个<code>__proto__</code>属性</li>
<li><code>__proto__</code>指向创建自己的那个构造函数的原型对象。</li>
<li>对象可以直接访问<code>__proto__</code>里面的属性和方法。</li>
</ul>
<p>4、constructor指向创建自己的那个构造函数。</p>
<h5 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h5><p>闭包：有权访问另一个函数作用域中的变量的函数。</p>
<p>闭包只能取得包含函数中任何变量的最后一个值。</p>
<p>闭包保存的是整个变量对象，而不是某个特殊的变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/14/day6/" data-id="ck087s6ha0008iwvcntnlxilj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/03/暑期总结/">暑期总结</a>
          </li>
        
          <li>
            <a href="/2019/07/24/day14/">day14</a>
          </li>
        
          <li>
            <a href="/2019/07/23/day13/">day13</a>
          </li>
        
          <li>
            <a href="/2019/07/20/day12/">day12</a>
          </li>
        
          <li>
            <a href="/2019/07/18/day11/">day11</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>