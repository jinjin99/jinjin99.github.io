<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-day12" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/20/day12/" class="article-date">
  <time datetime="2019-07-20T11:48:02.000Z" itemprop="datePublished">2019-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/20/day12/">day12</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h4><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><ul>
<li>类似于数组，但是成员的值都是唯一的，没有重复的值。</li>
<li>向set加入值的时候，不会发生类型转换。</li>
<li>判断两个值是否不同，使用的算法类似于（===），主要区别是set认为NaN等于自身，而精确相等运算符认为NaN不等于自身。</li>
<li>两个对象总是不相等，空对象也不相等。</li>
<li><code>Array.from</code>方法可以将 Set 结构转为数组。</li>
<li>Set结构键值和键名是同一个值。</li>
<li>方法<ul>
<li>add()</li>
<li>delete()</li>
<li>clear()</li>
</ul>
</li>
</ul>
<h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><ul>
<li>weakSet结构与Set类似，也是不重复的值的集合，但是与Set有两个区别。WeakSet的成员只能是对象，而不能是其他类型的值。</li>
</ul>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul>
<li>js的对象，本质上是键值对的集合，但是传统上只能用字符串当作键。</li>
<li>object结构提供“字符串——值”的对应，Map结构提供“值——值”的对应（各种类型的值（包括对象）都可以当作键）。</li>
<li>如果对同一个键多次赋值，后面的值将覆盖前面的值。</li>
<li>方法：<ul>
<li>set(key,value)</li>
<li>get(key);</li>
<li>delete(key)</li>
<li>clear()</li>
<li>has(key)</li>
</ul>
</li>
<li>如果Map的键是一个简单类型的值（数字，字符串，布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0.另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。</li>
</ul>
<h4 id="Promise协议"><a href="#Promise协议" class="headerlink" title="Promise协议"></a>Promise协议</h4><ul>
<li><p>Promise，就是一个容器，里面保存着某个未来才会结束的时间的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。</p>
</li>
<li><p>对象的状态不受外界影响。</p>
<ul>
<li>pending：进行中</li>
<li>fulfilled：已成功</li>
<li>rejected：已失败</li>
</ul>
</li>
<li><ul>
<li><p>Promise.all() ：所有请求都成功了才使用resolve。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([$.ajax(&#123;<span class="attr">url</span>:<span class="string">""</span>&#125;,<span class="attr">dataType</span>:<span class="string">'json'</span>),</span><br><span class="line">             $.ajax(&#123;<span class="attr">url</span>:<span class="string">""</span>&#125;,<span class="attr">dataType</span>:<span class="string">'json'</span>),</span><br><span class="line">             $.ajax(&#123;<span class="attr">url</span>:<span class="string">""</span>&#125;,<span class="attr">dataType</span>:<span class="string">'json'</span>),</span><br><span class="line">            ]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line"><span class="comment">//只有所有请求都成功了，才会使用第一个function。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li>Promise.race：</li>
</ul>
<h4 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h4><ul>
<li><p>普通函数——一条路走到底 中就不会停</p>
</li>
<li><p>generator函数——中间可以暂停</p>
</li>
<li><p>yield</p>
<ul>
<li><p>可以传参，可以返回</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">传参</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span>;</span><br><span class="line">    </span><br><span class="line">    alert(<span class="string">'b'</span>);</span><br><span class="line">    alert(a);<span class="comment">//5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = show();</span><br><span class="line">gen.next(<span class="number">12</span>);<span class="comment">//第一个传参无用</span></span><br><span class="line">gen.next(<span class="number">5</span>);<span class="comment">//参数传到yeied</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回</p>
</li>
</ul>
</li>
</ul>
<h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><p><code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></p>
<ul>
<li><code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li>
<li><code>async</code>函数的返回值是 Promise 对象，可以用<code>then</code>方法指定下一步的操作。</li>
</ul>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><ul>
<li>类的所有方法都定义在类的<code>prototype</code>属性上面。</li>
<li>类的内部所有定义的方法，都是不可枚举的。</li>
<li>类必须使用<code>new</code>调用，否则会报错。</li>
<li>实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</li>
<li>类不存在变量提升。</li>
<li>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，如果方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境。</li>
<li>如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</li>
<li>父类的静态方法，可以被子类继承。</li>
<li>Class 可以通过<code>extends</code>关键字实现继承。</li>
</ul>
<h4 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h4><ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">页面加载完后再执行该代码</span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>相当于原生js中的DOMContentLoaded</li>
<li>不同于原生种的load事件（等页面文档，外部js文件，css文件，图片加载完毕才执行内部代码）。</li>
</ul>
</li>
<li><p>原生js获取的对象是DOM对象，用jQuery获取的对象是jQuery对象。</p>
</li>
<li><p>jQuery对象只能使用jQuery 方法，DOM对象则使用原生的JavaScript属性和方法。</p>
</li>
<li><p>jQuery对象转成DOM对象</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>)[index];</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).get(index);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>隐形迭代</p>
<ul>
<li>给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化操作，方便调用。</li>
</ul>
</li>
<li><p>筛选选择器</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:eq(index);<span class="comment">//索引为index的元素，索引号从0开始。</span></span><br><span class="line">:odd<span class="comment">//索引为奇数的元素。</span></span><br><span class="line">:even<span class="comment">//索引号为偶数的元素。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/20/day12/" data-id="cjyegcsde0000h0vcsgy55dey" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/day11/" class="article-date">
  <time datetime="2019-07-18T12:53:29.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/day11/">day11</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li><p>使用默认值传值</p>
<ul>
<li>参数默认值不是传值的，而是每次都重新计算默认值表达式的值，也就是说，参数默认值是惰性求值。</li>
</ul>
</li>
<li><p>可以与解构赋值默认值结合使用</p>
<ul>
<li><p>如果没有提供参数，函数参数默认为一个空对象（按下列的写法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x,y=<span class="number">5</span>&#125;=&#123;&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line">foo()<span class="comment">//undefined 5</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// "GET"</span></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) </span>&#123; <span class="comment">//代码指定，如果没有提供第二个参数，就默认第二个参数为空对象。如果是一个对象，就可以为他的三个属性设置默认值。</span></span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://example.com'</span>)</span><br><span class="line"><span class="comment">// "GET"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>函数的length属性</p>
<ul>
<li>指定了默认值后，函数的length属性将返回没有指定默认值的参数个数，也就是说，指定了默认值后，length属性将失真。</li>
<li>length含义是，该函数预期传入的参数个数，某个参数指定默认值后，预期传入的参数个数就不包括这个参数了。</li>
<li>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域，等到初始化结束，这个作用域会消失，这种语法行为，在不设置参数默认值时是不会出现的。</li>
</ul>
</li>
</ul>
<h5 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h5><ul>
<li>形式为 …变量名 ，用于获取函数的多余参数。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</li>
<li>rest参数之后不能再有其他参数，否则会报错。</li>
<li>注意：函数的length属性，不包括rest</li>
</ul>
<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><ul>
<li><p>允许使用“箭头” =&gt; 定义函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不需要参数或者需要多个参数，就用一个圆括号代替参数部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span><span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> num1+num2;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于大括号会被解释成代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会出错。</p>
</li>
<li><p>函数体内的<code>this</code>对象，总是指向函数定义生效时所在的对象，而不是使用时所在的对象。</p>
</li>
<li><p>箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向。</p>
</li>
</ul>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><ul>
<li>对象的属性名可以有两种类型，一种是原来就有的字符串，另一种就是新增的symbol类型，凡是属性名属于symbol类型，就都是独一无二的，可以保证与其他属性名产生冲突。</li>
<li>Symbol 值不是对象，所以不能添加属性。不可以使用new命令。</li>
<li><a href="https://github.com/tc39/proposal-Symbol-description" target="_blank" rel="noopener">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</li>
<li>Symbol 值作为对象属性名时，不能用点运算符。</li>
<li>symbol作为属性名，该属性不会出现在for..in、for..of循环中，也不会被object.keys()等返回，但是，它不是私有属性，有一个object.getOwnPropertySymbols方法，可以获取指定对象的所有symbol属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的symbol值。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/18/day11/" data-id="cjyegcsen000bh0vcnnn3exwu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/day10/" class="article-date">
  <time datetime="2019-07-17T14:10:00.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/day10/">day10</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1</p>
<h4 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h4><ul>
<li>for循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</li>
<li>ES6的块级作用域必须有大括号，如果没有大括号，JavaScript引擎就不存在块级作用域。</li>
</ul>
<h5 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h5><ul>
<li><p>var 命令有变量提升现象，变量可以在声明之前使用，值为undefined。let命令改变了语法行为，他所声明的变量必须在声明后才可以使用，否则报错。</p>
</li>
<li><p>暂时性死区：只要在块级作用域内存在let命令，他所声明的变量就绑定这个区域，不受外部的影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    tmp=<span class="string">"abc"</span>;<span class="comment">//Error</span></span><br><span class="line">    <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在块级作用域内let声明了一个局部变量，绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>
</li>
</ul>
<h5 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h5><ul>
<li>const表明一个只读的常量，一旦声明，常量的值就不能改变。这也意味着一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
<li>const声明的常量只在声明的块级作用域内有效。</li>
<li>const命令声明的常量不提升，存在暂时性死区。</li>
<li>不可重复声明。</li>
<li>const保证的是变量指向的那个内存地址所保存的数据不可改变。对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的那个内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，这个指针指向的数据是不是可变的，就完全不可控制了。</li>
</ul>
<h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h4><h5 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h5><ul>
<li><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码表示从数组中提取值，按照对应位置，对变量赋值。</span></span><br><span class="line"><span class="comment">本质上，这种写法属于“模型匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果解构不成功，变量的值就等于undefined</p>
</li>
</ul>
<h6 id="默认值（数组）"><a href="#默认值（数组）" class="headerlink" title="默认值（数组）"></a>默认值（数组）</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>[foo = <span class="literal">true</span>]=[]</span><br><span class="line">foo<span class="comment">//true;</span></span><br><span class="line"><span class="keyword">let</span>[x,y=<span class="string">'b'</span>] = [<span class="string">'a'</span>]<span class="comment">//x='a',y='b';</span></span><br><span class="line"><span class="keyword">let</span>[x,y=<span class="string">'b'</span>]=[<span class="string">'a'</span>,undefiend];<span class="comment">//x='a',y='b';</span></span><br><span class="line"><span class="comment">//只有一个数组成员严格等于undefined，默认值才会生效</span></span><br><span class="line"><span class="keyword">let</span>[x=<span class="number">1</span>]=[<span class="literal">null</span>]<span class="comment">//x=null null不严格等于undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果默认值是一个表达式，那么这个表达式是惰性求值，只有在用到的时候，才会求值。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x=f()] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">//此时，因为x能取到值，所以f不会被执行。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h5><ul>
<li><p>解构不仅可以用于数组，还可以用于对象。</p>
</li>
<li><p>对象的结构与数组有一个重要的不同，数组的元素是按次序排序的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须和属性同名，才能去到正确的值。</p>
</li>
<li><p>如果变量名和属性名不一样，写成下面那样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>:baz&#125; = &#123;<span class="attr">foo</span>:<span class="string">"aaa"</span>,<span class="attr">bar</span>:<span class="string">"bbb"</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(baz);<span class="comment">//"aaa"</span></span><br><span class="line"><span class="comment">//对象解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h6><ul>
<li>默认值生效的条件是，对象的属性值严格等于undefined。</li>
</ul>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//上面代码的写法会报错，因为JavaScript引擎会把&#123;x&#125;理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;);<span class="comment">//这样才正确。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/17/day10/" data-id="cjyegcsdr0003h0vc6jf021w8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day9" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/day9/" class="article-date">
  <time datetime="2019-07-17T01:07:22.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/day9/">day9</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="vw和vh"><a href="#vw和vh" class="headerlink" title="vw和vh"></a>vw和vh</h4><p>vw是可视窗口的宽度单位，1vw = 可视窗口的百分之一。与百分比不一样的是，vw始终相对于可视窗口的宽度，而百分比和父元素的宽度有关。</p>
<p>vh则是可视窗口的高度。</p>
<p>vmin：选择vw和vh最小的那个</p>
<p>vmax：选择最大的那个。</p>
<h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>1、touch：移动端的触摸，是一组事件。</p>
<ul>
<li>e.touches[0]：第一个触摸点</li>
<li>clientX clientY ：基于浏览器窗口</li>
<li>pageX pageY ：基于页面</li>
<li>screenX screenY：基于屏幕</li>
</ul>
<p>2、touchstart：当触摸屏幕的时候触发。</p>
<p>3、touchend：当手指离开屏幕的时候触发。</p>
<p>4、touchmove：手指在屏幕中来回滑动触发。</p>
<p>5、touchcancel：被迫中止手势滑动的时候触发。</p>
<p>以上对象都有以下的属性：</p>
<ul>
<li>touchList：触摸点的集合。<ul>
<li>触摸点：一个手指就是一个出发点，和屏幕接触点的个数。</li>
</ul>
</li>
<li>changedTouches：改变后的触摸点的集合。</li>
<li>targetTouches：当前元素的触发点的集合。</li>
<li>touches：页面上所有触发点的集合。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/17/day9/" data-id="cjyegcsej000ah0vch3lges09" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/day8/" class="article-date">
  <time datetime="2019-07-16T01:08:06.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/day8/">day8</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"150"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>canvas标签只有两个属性，width和height，这些都是可选的。但没有设置宽度和高度时，canvas会初始化宽度为300像素和高度为150像素。该元素可以使用css来定义大小，但是在绘制图形时会伸缩以适应它的框架尺寸，如果css尺寸与初始画布比例不一致，它会出现扭曲。</p>
<h5 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h5><p>canvas起初是空白的，为了展示，首先脚本需要找到渲染上下文，然后在它上面绘制。</p>
<p>canvas元素有getContext()方法，这个方法是用来获得渲染上下文和它的绘画功能。getContext()只有一个参数，上下文的格式。</p>
<h5 id="创建矩形"><a href="#创建矩形" class="headerlink" title="创建矩形"></a>创建矩形</h5><ul>
<li>ctx.fillRect(x,y,width,height)：绘制一个填充矩形<ul>
<li>x：矩形起始点的x轴坐标</li>
<li>y：矩形起始点y轴的坐标</li>
<li>width：矩形的宽度</li>
<li>height：矩形的高度</li>
</ul>
</li>
<li>ctx.strokeRect(x,,y,width,height)：绘制一个描边矩形<ul>
<li>width:矩形的宽度，正值在右侧，负值在左侧。</li>
<li>height：矩形的高度。正直在下，负值在上。</li>
</ul>
</li>
<li>clearRect(x,y,width,height)：清除指定矩形区域，让清除部分完全透明。</li>
</ul>
<h5 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h5><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。</p>
<p>利用路径绘制图形需要一些额外的步骤</p>
<ul>
<li>创建路径起始点</li>
<li>使用画图命令去画路径</li>
<li>把路径封闭</li>
<li>一旦路径生成，就可以通过秒表或填充路径区域来渲染图形。</li>
</ul>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><ul>
<li>beginPath()：新建一条路径，生成之后，图形绘制命令被指到路径上生成路径。</li>
<li>closePath()：闭合路径之后图形绘制命令又重新指向到上下文中。</li>
<li>stroke()：通过线条来绘制图形轮廓</li>
<li>fill()：通过填充路径的内容区域来生成实心的图形。<ul>
<li>调用该函数时，没有闭合的路径会自动闭合，但是调用stroke函数不会。</li>
</ul>
</li>
<li>moveTo(x,y)：将笔触移动到指定的坐标x和y上。</li>
<li><code>arc(100,75,50,0*Math.PI,1.5*Math.PI，false)</code><ul>
<li>圆的中心(100,75)</li>
<li>起始角：0</li>
<li>圆的半径：50</li>
<li>结束角：1.5*Math.PI</li>
<li>默认为顺时针</li>
<li>false：顺时针 true：逆时针</li>
</ul>
</li>
<li>lineTo(x,y)：绘制一条从当前位置到指定x以及y位置的直线。</li>
</ul>
<h5 id="二次贝塞尔曲线及三次贝塞尔曲线"><a href="#二次贝塞尔曲线及三次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线及三次贝塞尔曲线"></a>二次贝塞尔曲线及三次贝塞尔曲线</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quadraticCurveTo(cp1x, cp1y, x, y)</span><br></pre></td></tr></table></figure>

<p>绘制二次贝塞尔曲线，<code>cp1x,cp1y</code>为一个控制点，<code>x,y为</code>结束点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</span><br></pre></td></tr></table></figure>

<p>绘制三次贝塞尔曲线，<code>cp1x,cp1y</code>为控制点一，<code>cp2x,cp2y</code>为控制点二，<code>x,y</code>为结束点。</p>
<h5 id="Path2D对象"><a href="#Path2D对象" class="headerlink" title="Path2D对象"></a>Path2D对象</h5><p>Path2D会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Path2D()<span class="comment">//空的path对象</span></span><br><span class="line"><span class="keyword">new</span> Path2D(path)<span class="comment">//克隆path对象</span></span><br><span class="line"><span class="keyword">new</span> Path2D(d) <span class="comment">//从svg建立path对象</span></span><br></pre></td></tr></table></figure>

<p>Path2D添加了 addPath 作为将Path结合起来的方法。</p>
<h5 id="添加颜色"><a href="#添加颜色" class="headerlink" title="添加颜色"></a>添加颜色</h5><p>fillStyle = color ：设置图形的填充颜色</p>
<p>strokeStyle = color ：设置图形轮廓的颜色</p>
<p>注意：一旦设置了strokeStyle或者fillStyle的值，那么这个新值就会成为新绘制的图形的默认值。如果要给每个图形上不同的颜色，就需要重新设置fillStyle或strokeStyle的值。</p>
<h5 id="lineStyle"><a href="#lineStyle" class="headerlink" title="lineStyle"></a>lineStyle</h5><h6 id="1、lineWdith：设置线条宽度"><a href="#1、lineWdith：设置线条宽度" class="headerlink" title="1、lineWdith：设置线条宽度"></a>1、lineWdith：设置线条宽度</h6><p>注意：注意奇偶数时在画布上的渲染。</p>
<h6 id="2、lineCap属性：线段端点显示的样子"><a href="#2、lineCap属性：线段端点显示的样子" class="headerlink" title="2、lineCap属性：线段端点显示的样子"></a>2、lineCap属性：线段端点显示的样子</h6><ul>
<li>butt：默认值，与辅助线齐平。</li>
<li>round：端点处加上了半径为一半线段的半圆。</li>
<li>square：加上了等宽且高度为一般线宽的方块。</li>
</ul>
<h6 id="3、lineJoin：图形中两线段连接处所显示的样子。"><a href="#3、lineJoin：图形中两线段连接处所显示的样子。" class="headerlink" title="3、lineJoin：图形中两线段连接处所显示的样子。"></a>3、lineJoin：图形中两线段连接处所显示的样子。</h6><ul>
<li>round：边角处背磨圆，圆的半径等于线宽</li>
<li>bevel：</li>
<li>miter：默认值，线段会在连接处外侧延伸直至交于一点。</li>
</ul>
<h4 id="动画的基本步骤"><a href="#动画的基本步骤" class="headerlink" title="动画的基本步骤"></a>动画的基本步骤</h4><h6 id="1、清空canvas"><a href="#1、清空canvas" class="headerlink" title="1、清空canvas"></a>1、清空canvas</h6><p>除非接下来要画的内容会充满canvas（例如背景图），否则需要清空所有，最简单的做法是用clearRect()方法</p>
<h6 id="2、保存canvas状态"><a href="#2、保存canvas状态" class="headerlink" title="2、保存canvas状态"></a>2、保存canvas状态</h6><p>如果要改变canvas状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，需要保存。</p>
<h6 id="3、绘制动画图形"><a href="#3、绘制动画图形" class="headerlink" title="3、绘制动画图形"></a>3、绘制动画图形</h6><h6 id="4、恢复canvas状态"><a href="#4、恢复canvas状态" class="headerlink" title="4、恢复canvas状态"></a>4、恢复canvas状态</h6><p>如果保存了canvas状态，可以先恢复它，然后重绘下一帧。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul>
<li><p>rotate()</p>
<ul>
<li>参数：以弧度制</li>
<li>旋转中心在整个画布的左上角，旋转的正方向是顺时针，反方向是逆时针。</li>
<li>canvas中rotate方法是绕画布左上角（0，0）进行旋转的，而且会受到translate影响。</li>
</ul>
</li>
<li><p>save()</p>
<ul>
<li>当前的变换矩阵</li>
<li>当前的剪切区域</li>
<li>当前的虚线列表</li>
<li>一些属性当前的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">ctx.save();<span class="comment">//保存默认的状态</span></span><br><span class="line">ctx.fillStyle = <span class="string">" "</span>;</span><br><span class="line">......</span><br><span class="line">ctx.restore();<span class="comment">//还原到上次保存的默认状态</span></span><br></pre></td></tr></table></figure>

<p>每调用一次restore方法，上一次保存的状态就从栈中弹出，所有设定都恢复。</p>
</li>
<li><p>translate</p>
<ul>
<li>移动canvas原点</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/day8/" data-id="cjyegcsef0008h0vcr74oj32n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day7" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/15/day7/" class="article-date">
  <time datetime="2019-07-15T01:06:13.000Z" itemprop="datePublished">2019-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/15/day7/">day7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="作用域的控制机制"><a href="#作用域的控制机制" class="headerlink" title="作用域的控制机制"></a>作用域的控制机制</h4><p>1、每个函数都有各自的作用域，作用域链，变量对象，执行环境。</p>
<p>其中，作用域链在函数初始化完成后便存在，而作用域，变量对象，执行环境只有在函数执行时才创建。</p>
<p>执行结束后，<strong>函数的作用域，作用域链，执行环境被销毁</strong>，而变量对象仍可能留在内存中。（如果函数内部有闭包，则函数执行结束后，变量对象仍然留在内存，知道闭包执行结束，该变量对象才会被销毁。）</p>
<p>2、作用域链</p>
<ul>
<li>把多个作用域串起来便形成了作用域链</li>
<li>每个函数在初始化完成后就拥有了各自的作用域链，但此时作用域链中并不包含自己的作用域，只有函数执行时，才会创建自己的作用域，并加在作用域的开头。</li>
<li>作用域链中不仅存储了函数本身的作用域，还存储了该函数能够访问的其他函数的作用域。</li>
</ul>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>1、概念：闭包是函数和引用环境组成的整体。环境包含了这个闭包创建时所能访问的所有局部变量。</p>
<p>函数是一些可执行代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的环境组合可以产生不同的实例。</p>
<p>2、作用：</p>
<ul>
<li>可以在函数的外部访问到函数内部的局部变量。</li>
<li>让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</li>
</ul>
<p>3、函数表达式声明方式并且声明后加上了()，所以会自动执行一次。</p>
<p><a href="https://blog.csdn.net/u010425776/article/details/53557942" target="_blank" rel="noopener">1</a></p>
<p><a href="https://blog.csdn.net/u010425776/article/details/53617292" target="_blank" rel="noopener">2</a></p>
<p><a href="https://blog.csdn.net/u010425776/article/details/53704179" target="_blank" rel="noopener">3</a></p>
<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p>Ajax是一种无需重新加载整个网页的情况下，能够更新部分网页的技术。</p>
<h6 id="1、XMLHttpRequest对象"><a href="#1、XMLHttpRequest对象" class="headerlink" title="1、XMLHttpRequest对象"></a>1、XMLHttpRequest对象</h6><p>Ajax核心是XMLHttpRequest对象（XHR），XHR向服务器发送请求和解析服务器响应提供了接口，能够以异步方式从服务器获取新数据。</p>
<p>XHR的主要属性：</p>
<ul>
<li>Number readyState 状态值<ul>
<li>0：未初始化。未调用open()方法。</li>
<li>1：启动。已经调用open()方法，为调用send()方法。</li>
<li>2：发送。已经调用send()方法，为接受到响应。</li>
<li>3：接受。已经接受到部分数据。</li>
<li>4：完成。已经接受到全部数据，可以在客户端使用。</li>
</ul>
</li>
<li>向服务器发送请求，使用XMR对象的open和send方法。<ul>
<li>open(method,url,async)<ul>
<li>method：请求的类型，get或者post</li>
<li>url：文件在服务器上的位置</li>
<li>async：true（异步）或false（同步）</li>
</ul>
</li>
<li>send(string)：将请求发送到服务器。<ul>
<li>string：仅用于post请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="2、Get请求"><a href="#2、Get请求" class="headerlink" title="2、Get请求"></a>2、Get请求</h6><p>Get用于向服务器查询某些信息</p>
<h6 id="3、post请求"><a href="#3、post请求" class="headerlink" title="3、post请求"></a>3、post请求</h6><p>post请求用于向服务器发送应该被保存的数据。post请求的主体可以包含非常多的数据，而且格式不限。</p>
<p>注意：在一下情况下，使用post请求</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（post没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，post比get更稳定可靠。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/15/day7/" data-id="cjyegcsdw0005h0vc96ph31eb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/day6/" class="article-date">
  <time datetime="2019-07-14T01:02:34.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/14/day6/">day6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="1、JS中new一个对象的过程"><a href="#1、JS中new一个对象的过程" class="headerlink" title="1、JS中new一个对象的过程"></a>1、JS中new一个对象的过程</h5><p>var obj = new ClassA();</p>
<p>1、创建空对象；</p>
<p>var obj = {};</p>
<p>2、设置新对象的constructor属性为构造函数的名称，设置新对象的<code>__proto__</code>属性指向构造函数的prototype对象</p>
<p><code>obj.__proto__ = ClassA.prototype</code>;</p>
<p>3、使用新对象调用函数，函数中this被指向新实例对象</p>
<p>ClassA.call(obj);</p>
<p>4、将初始化完毕的新对象地址，保存到等号左边的变量中。</p>
<h5 id="2、关于原型一些总结"><a href="#2、关于原型一些总结" class="headerlink" title="2、关于原型一些总结"></a>2、关于原型一些总结</h5><p>1、原型属性中若有引用值类型，对实例进行修改，原型中该数值也会被修改。</p>
<p>而基本类型值不会被修改。</p>
<p>2、每个函数都有一个prototype属性，这个属性指向一个对象，这个对象我们叫做原型对象。</p>
<p>3、</p>
<ul>
<li>每个对象都有一个<code>__proto__</code>属性</li>
<li><code>__proto__</code>指向创建自己的那个构造函数的原型对象。</li>
<li>对象可以直接访问<code>__proto__</code>里面的属性和方法。</li>
</ul>
<p>4、constructor指向创建自己的那个构造函数。</p>
<h5 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h5><p>闭包：有权访问另一个函数作用域中的变量的函数。</p>
<p>闭包只能取得包含函数中任何变量的最后一个值。</p>
<p>闭包保存的是整个变量对象，而不是某个特殊的变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/14/day6/" data-id="cjyegcse70007h0vcq7pmkwdx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/12/day5/" class="article-date">
  <time datetime="2019-07-12T01:03:03.000Z" itemprop="datePublished">2019-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/12/day5/">day5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h5><p>1、找到数组找你的最大值或最小值，可以像下面这样使用apply()方法。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>,values);</span><br><span class="line"><span class="comment">//将Math对象作为apply()的第一个参数，从而正确地设置this值。然后可以将任何数组作为第二个参数</span></span><br></pre></td></tr></table></figure>

<h6 id="3、舍入方法"><a href="#3、舍入方法" class="headerlink" title="3、舍入方法"></a>3、舍入方法</h6><ul>
<li>Math.ceil()：执行向上舍入，即它只是将数值向上舍入为最接近的整数。</li>
<li>Math.floor()：向下舍入，即它总什将数值向下舍入为最接近的整数</li>
<li>Math.round()：标准舍入，四舍五入。</li>
</ul>
<h6 id="4、rondom-方法"><a href="#4、rondom-方法" class="headerlink" title="4、rondom()方法"></a>4、rondom()方法</h6><p>Math.random()：返回0-1之间的一个随机数。</p>
<h4 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h4><h5 id="1、数据属性"><a href="#1、数据属性" class="headerlink" title="1、数据属性"></a>1、数据属性</h5><p>数据属性有4个描述其行为的特性</p>
<ul>
<li>[[]Configurable]]</li>
<li>[[Enumerable]]</li>
<li>[[Writable]]</li>
<li>[[Value]]</li>
</ul>
<p>修改属性默认的特性，使用Object.defineProperty()方法，要传入3个参数：属性所在的对象，属性的名字，描述符对象。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">object.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writable:<span class="literal">false</span>;<span class="comment">//设置成不可修改</span></span><br><span class="line">    value:<span class="string">"Nicholoas"</span>;<span class="comment">//将person.name的值设置成N....</span></span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">"Grey"</span>;</span><br><span class="line">alert(person.name);<span class="comment">//Nicholoas</span></span><br></pre></td></tr></table></figure>

<p>将configurable设置成false，表明不能从对象中删除属性。可以多次调用调用objec.defineProperty()方法修改同一属性，但是把configurable设置成false后就有限制了。把属性定义为不可配置的，就不能再把它便会可配置的了。再调用该方法修改除written外的特性都会出错。</p>
<h5 id="2、访问器属性"><a href="#2、访问器属性" class="headerlink" title="2、访问器属性"></a>2、访问器属性</h5><ul>
<li>[[]Configurable]]</li>
<li>[[Enumerable]]</li>
<li>[[Get]]：在读取属性时调用的函数，默认为undefined。</li>
<li>[[Set]]：在写入属性时调用的函数，默认为undefined。</li>
</ul>
<h5 id="原型链与继承"><a href="#原型链与继承" class="headerlink" title="原型链与继承"></a>原型链与继承</h5><p>原型：我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象（函数的原型对象），而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>
<p>原型对象：原型对象会自动获得一个constructor（构造函数）属性，这个属性是一个值向prototype属性所在函数的指针。</p>
<p>实例（instance）：包含一个指向原型对象的内部指针。</p>
<p>原型链：实例与原型的链条称作原型链。</p>
<p><a href="http://louiszhai.github.io/2015/12/15/prototypeChain/" target="_blank" rel="noopener">博客</a></p>
<h6 id="1、构造函数继承"><a href="#1、构造函数继承" class="headerlink" title="1、构造函数继承"></a>1、构造函数继承</h6><p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.emotion = [<span class="string">'喜'</span>,<span class="string">'怒'</span>,<span class="string">'哀'</span>,<span class="string">'乐'</span>]；</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">Id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.Id = Id;</span><br><span class="line">    Person.call(<span class="keyword">this</span>)<span class="comment">//!!!!!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> Student(<span class="number">1001</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu1.emotion);<span class="comment">//喜怒哀乐</span></span><br><span class="line">stu1.emotion.push(<span class="string">'愁'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu1.emotion);<span class="comment">//喜怒哀乐愁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> Student(<span class="number">1002</span>);</span><br><span class="line"><span class="built_in">console</span>.log(stu2.emotion)<span class="comment">//喜怒哀乐</span></span><br></pre></td></tr></table></figure>

<p>缺点：借用构造函数继承，使stu1和stu2都有各自的父类属性副本，从而使各自的emotion互不影响，但他是带来的问题是，stu1和stu2都拷贝了Person中所有的属性和方法，而添加到每个实例上，增大内存，尤其是方法比较多的时候。</p>
<p><a href="https://www.cnblogs.com/sarahwang/p/6879161.html" target="_blank" rel="noopener">blog</a></p>
<h6 id="2、结合-原型链继承-和-借用函数继承"><a href="#2、结合-原型链继承-和-借用函数继承" class="headerlink" title="2、结合 原型链继承 和 借用函数继承"></a>2、结合 原型链继承 和 借用函数继承</h6><p>使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</p>
<p><a href="https://www.cnblogs.com/sarahwang/p/9098044.html" target="_blank" rel="noopener">blog</a></p>
<p><a href="http://louiszhai.github.io/2015/12/15/prototypeChain/" target="_blank" rel="noopener">博客</a></p>
<h6 id="3、new的过程"><a href="#3、new的过程" class="headerlink" title="3、new的过程"></a>3、new的过程</h6><p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>new的过程拆分成三步：</p>
<p>1）var p ={} ，初始化一个p对象</p>
<p>2）<code>p__proto__</code>=Person.prototype;</p>
<p>3）Person.call(p); </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/12/day5/" data-id="cjyegcsdz0006h0vc1rn6ogda" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/11/day4/" class="article-date">
  <time datetime="2019-07-11T01:01:15.000Z" itemprop="datePublished">2019-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/11/day4/">day4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h5><p>1、调用Date构造函数而不必传递参数情况下，新创建的对象自动获得当前日期和时间。</p>
<p>2、Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。</p>
<p>3、和其他引用类型一样，Date重写了toString(),toLocaleString,valueOf()方法。</p>
<ul>
<li>toLocaleString：按照与浏览器设置的地区相适应的格式返回日期和时间</li>
<li>toString：返回带有时区信息的日期和时间，使劲按一般以军用时间（小时范围0-23）</li>
<li>valueOf：不返回字符串，而是返回日期的毫秒数。因此可以用比较操作符来比较日期。使用alert（）时，后台会自动使用valueOf。</li>
</ul>
<p>4、toUTCString()：以特定于实现的格式完整的UTC日期。（推荐使用）</p>
<h5 id="RexExp类型"><a href="#RexExp类型" class="headerlink" title="RexExp类型"></a>RexExp类型</h5><p>ECMAScript通过RegExp类型来支持正则表达式。</p>
<p>eg：正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags;<span class="comment">//类似Perl语法</span></span><br></pre></td></tr></table></figure>

<p>pattern部分可带有一个或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。</p>
<ul>
<li>g：表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止。</li>
<li>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串 的大小写。</li>
<li>m：表示多行（multiple）模式，即在到达一行文本末尾时还会继续查找下一行是否存在与模式匹配的项。</li>
</ul>
<p>1、元字符：（   {   [    \     ^    $   |    )  ?    *    +    .    ]   }   </p>
<p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对他们进行转义。</p>
<p>2、由于RegExp构造函数的模式参数是字符串，所以在某些情况下，要对字符串进行双重转义。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;<span class="comment">//表示匹配第一个[bc]at，不分大小写</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>,<span class="string">"i"</span>)<span class="comment">//双重转义。</span></span><br><span class="line"><span class="comment">//pattern1和pattern2相同，只不过是2是构造函数构建的。</span></span><br></pre></td></tr></table></figure>

<h6 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h6><ul>
<li><p>global：布尔值，表示是否设置了g标志</p>
</li>
<li><p>ignoreCase：布尔值，表示是否设置了i标志</p>
</li>
<li><p>lastIndex：整数，表示开始搜下下一个匹配项的字符位置，从0算起。</p>
</li>
<li><p>multiline：布尔值，表示是否设置了m标志</p>
</li>
<li><p>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>,<span class="string">"i"</span>);</span><br><span class="line">alert(pattern2.global);<span class="comment">//false</span></span><br><span class="line">alert(pattern2.ignoreCase);<span class="comment">//true</span></span><br><span class="line">alert(pattern2.multiline);<span class="comment">//false</span></span><br><span class="line">alert(pattern2.lastIndex);<span class="comment">//0</span></span><br><span class="line">alert(pattern2.source);<span class="comment">//"\[bc\]at"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h6><ul>
<li><p>exec()方法：用于检索字符串中的正则表达式的匹配，返回值是一个数组，但该数组的内容和正则对象是否是全局匹配有很大关系。</p>
<p>1、没有g修饰符：在非全局匹配模式下，此函数的作用和match()函数一样，只能够在字符串中匹配一次，如果没有找到匹配的字符串，那么返回null，否则返回一个数组，<strong>数组的第0个元素存储的是匹配字符串，第1个元素存放的是第一个子表达式（正则中用（）包住的部分）匹配的字符串，以此类推。</strong>同时该数组包括两个对象属性，index属性表明匹配字符串的其实字符在要匹配的完整字符串中的位置，input属性声明的是对要匹配的完整字符串的引用。</p>
<p>2、有g修饰符：在全局匹配模式下，此函数返回值同样是一个数组，并且也只能匹配一次，不过此时，此函数一般会和lastIndex属性匹配使用，此函数会在lastIndex属性指定的字符处开始检索字符串，当exec()找到与表达式相匹配的字符串时，在匹配后，它将<strong>lastIndex属性设置为匹配字符串的最后一个字符的下一个位置</strong>。可以丰富调用exec()函数遍历字符串中所有的匹配，知道再也找不到匹配的文本，它将返回null，并将lastIndex属性重置为0.</p>
<p>注：数组的内容结构和没有g修饰符完全相同。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"abbb34eftab0modabbbbbbb6"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a(b)+(\d+)/i</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.match(reg);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(arr[i]);</span><br><span class="line">    <span class="comment">//如果是g全局，那么返回所有匹配[abbb34,ab0,abbbbbbb6]</span></span><br><span class="line">    <span class="comment">//如果没有g全局，那么返回arr[0],后面则是字表达式的捕获。[abbb34,b,34]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h5><ul>
<li><p>函数声明：解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）。</p>
</li>
<li><p>函数表达式：必须等到解析器执行到它所在的代码行，才会真正被解析。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样可以使用。</span></span><br><span class="line"></span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会出错。</span></span><br></pre></td></tr></table></figure>

<p>原因：第一个是函数声明，在代码开始执行前，解析器就通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍声明函数并将它们放在源代码树的顶部。</p>
<p>而第二个不是</p>
</li>
</ul>
<h6 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h6><ul>
<li>arguments</li>
<li>callee：是arguments的一个属性，该属性是一个指针，值向拥有这个arguments对象的函数。不能为这个属性赋值，否则会发生错误。</li>
<li>this：函数执行的环境对象——或者可以说是this值（当在页面的全局作用域中调用函数时，this对象引用的就是window）</li>
</ul>
<p>注意：函数的名字仅仅是一个包含指针的变量。</p>
<h6 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h6><ul>
<li><p>属性</p>
<ul>
<li><p>length：函数希望接收的命名参数的个数。</p>
</li>
<li><p>prototype（原型）：为一个特定类声明通用的变量或者函数。</p>
<p><a href="https://www.cnblogs.com/dengpeng1004/p/5317245.html" target="_blank" rel="noopener">博客</a></p>
</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li>apply()：接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组。</li>
<li>call()：</li>
</ul>
<p>作用：可以扩充函数赖以运行的作用域</p>
</li>
</ul>
<h6 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h6><p>注意：使用new调用基本包装类型的构造函数，和直接调用同名的转型函数是不一样的。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value);<span class="comment">//转型函数</span></span><br><span class="line">alert (<span class="keyword">typeof</span> number);<span class="comment">//"number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value);<span class="comment">//构造函数</span></span><br><span class="line">alert (<span class="keyword">typeof</span> obj);<span class="comment">//"object"</span></span><br><span class="line"><span class="comment">//在这个例子中，number保存的是基本类型的值，而obj保存的是Number的实例。</span></span><br></pre></td></tr></table></figure>

<p>自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立刻被销毁。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line">s1.color = <span class="string">"red"</span>;</span><br><span class="line">alert(s1.color)<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>第二行代试图为字符串s1添加一个属性，但是，当第三行代码再次访问s1时，其color属性不见了。原因是第二行创建的String对象，在执行第三行代码时已经被销毁了。第三行代码又创建了自己的String对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/11/day4/" data-id="cjyegcsdo0002h0vcpm3u14b1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/10/day3/" class="article-date">
  <time datetime="2019-07-10T01:15:21.000Z" itemprop="datePublished">2019-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/day3/">day3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><h5 id="1、for-in-语句"><a href="#1、for-in-语句" class="headerlink" title="1、for in 语句"></a>1、for in 语句</h5><p>概念：遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量 <span class="keyword">in</span> 对象)</span><br><span class="line">    <span class="comment">//“变量”用来指定变量，指定的变量可以是数组元素，也可以是对象的属性。</span></span><br><span class="line">&#123;</span><br><span class="line">    在此执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、label-语句"><a href="#2、label-语句" class="headerlink" title="2、label 语句"></a>2、label 语句</h5><p>使用label语句可以在代码中添加标签，以便将来使用。可以由break或continue语句引用。</p>
<h5 id="3、switch语句"><a href="#3、switch语句" class="headerlink" title="3、switch语句"></a>3、switch语句</h5><p>注意：switch语句在比较值的时候，用的是全等操作符，因此不会发生类型转换。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="1、参数"><a href="#1、参数" class="headerlink" title="1、参数"></a>1、参数</h5><ul>
<li>命名的参数只提供便利，但不是必需。</li>
<li>ECMAScript函数不介意传递进来的参数多少个，什么类型。因为传进来的参数用一个数组来表示。在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。</li>
<li>arguments对象只是与数组类似（但不是数组），可以用方括号语法访问它的每一个元素，可以使用length属性确定传递进来几个参数。但是没有数组的其他特性。</li>
</ul>
<h5 id="2、不能重载"><a href="#2、不能重载" class="headerlink" title="2、不能重载"></a>2、不能重载</h5><p>重载：用同样的方法名，传递不同的参数，实现不同的目的。</p>
<ul>
<li>在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。</li>
</ul>
<hr>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量包含两种不同数据类型的值：</p>
<ul>
<li><p>基本类型值：简单的数据段。：五种基本数据类型，按值访问。（可给基本类型添加属性，但在下次访问该属性时，发现该属性会不见。）</p>
</li>
<li><p>引用类型值：可能由多个值构成的对象。可以动态的添加属性，以便将来使用。（添加属性时，如果对象不被销毁或者这个属性不被删除，则这个属性将一只存在。）<strong>值保存在内存中。</strong></p>
<p><strong>注意：按引用访问：在js中不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，再按照这个地址去获得这个对象的值。</strong></p>
</li>
</ul>
<h5 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h5><ul>
<li>基本类型值：如果从一个变量向另一个变量复制基本类型的值时，会在变量对象上创建一个新，然后把该值复制到为新变量分配的位置上。<strong>复制与被复制的变量是完全独立的，这两个变量可以参与任何操作而不会相互影响。</strong></li>
<li>引用类型值：同样会将存储在变量对象中的值复制一份放到新变量分配的空间中，不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。<strong>复制结束后，两个变量实际上将引用同一个对象。</strong></li>
</ul>
<h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>ECMASCript中所有函数的参数都是按值传递的。</p>
<h5 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h5><p>instanceof操作符，可以怕判断某个值是什么类型的对象</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//person是object吗</span></span><br><span class="line">alert(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line"><span class="comment">//如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false</span></span><br></pre></td></tr></table></figure>

<h4 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h4><h5 id="1、作用域"><a href="#1、作用域" class="headerlink" title="1、作用域"></a>1、作用域</h5><ul>
<li><p>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p>
</li>
<li><p>作用：提高了程序的逻辑的局部性，增强程序的可靠性，以及避免命名冲突，为代码的模块化开发提供便利。</p>
</li>
</ul>
<h5 id="2、作用域链"><a href="#2、作用域链" class="headerlink" title="2、作用域链"></a>2、作用域链</h5><p>每个函数都有自己的执行环境，包含当前环境的变量访问关系，与之相关联的就是“变量对象”，如果是当前函数的变量对象，也可以称之为“活动对象”。该对象包含了：当前函数可访问的变量及函数。</p>
<p>eg </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">"test"</span>;</span><br><span class="line">    <span class="comment">//变量对象中包含：命名函数fn变量，参数name，内部变量test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：变量对象是不可访问的，只提供后台引擎编译执行使用，当定义由多个变量对象嵌套，这些变量对象就组成了作用域链。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">super</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"super"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">"sub"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子构成的作用域链为：</p>
<p>全局变量对象window——&gt; 变量对象super——&gt; 活动对象sub</p>
<p>变量访问原则是，根据作用域前端往上搜索，如果提前搜索到变量，就停止搜索，例如上面的例子中，name变量的值是sub，因为其再最前端的变量对象中就已经定义了，则不会往上继续检索。</p>
<h5 id="3、延长作用域"><a href="#3、延长作用域" class="headerlink" title="3、延长作用域"></a>3、延长作用域</h5><p>1、try-catch语句的catch块</p>
<p>2、with语句(不用)</p>
<h5 id="4、执行环境只与函数的声明及定义位置有关"><a href="#4、执行环境只与函数的声明及定义位置有关" class="headerlink" title="4、执行环境只与函数的声明及定义位置有关"></a>4、执行环境只与函数的声明及定义位置有关</h5><p>当一个函数定义后，其执行环境与作用域链就已经确定了，不会因为执行位置改变而改变。</p>
<hr>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="1、object类型"><a href="#1、object类型" class="headerlink" title="1、object类型"></a>1、object类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person =&#123;&#125; <span class="comment">//相当于 new Object();</span></span><br><span class="line"><span class="comment">//访问对象的属性</span></span><br><span class="line">person[<span class="string">"name"</span>];</span><br><span class="line">person.name;</span><br><span class="line">person[<span class="string">"first name"</span>]</span><br><span class="line"><span class="comment">//由于first name含有空格，用点访问会出错，可以用方括号表示来访问。</span></span><br><span class="line"><span class="comment">//通常情况下，除非必须用变量来访问属性，否则建议用点表示法。</span></span><br></pre></td></tr></table></figure>

<h5 id="2、Array类型"><a href="#2、Array类型" class="headerlink" title="2、Array类型"></a>2、Array类型</h5><ul>
<li>数组的length不仅仅只读，还可以进行修改，若数组含有三个元素，将length改成2，则最后一个元素将会被移除。</li>
</ul>
<h6 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h6><ul>
<li>instanceof操作符的问题在于，它假定只有一个全局执行环境，如果一个网页中包含多个框架，那实际上存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数</li>
<li>为了解决上述问题，新增了Array.isArray()方法，这个方法目的是最终确定某个值是不是数组，而不管它在在哪个全局执行环境中创建的。</li>
</ul>
<h6 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h6><ul>
<li><p>所有对象都有toLocaleString()、toString()、valueOf()方法。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">alert(colors.toString());<span class="comment">//red,blue,green</span></span><br><span class="line">alert(colors.valueOf());<span class="comment">//red,blue,green</span></span><br><span class="line">alert(colors);<span class="comment">//red,blue,green</span></span><br></pre></td></tr></table></figure>

<p>显式的调用toString()方法，每个值的字符串表示拼接成了一个字符串，中间要用逗号分隔。</p>
<p>由于alert()要接受字符串参数，所以它在后台调用toString()方法，由此会得到与直接调用toString()方法相同的结果。</p>
</li>
<li><p>join()方法，可以用不同的分隔符来构建这个字符串。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line">colors.join(<span class="string">"||"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果数组中某一项的值是null或者undefined，那么该值在join(),toLocaleString(),toString(),valueOf()方法返回的结果中以空字符串表示。</p>
</li>
</ul>
<h6 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h6><ul>
<li><p>shift()：从头部删除一个值</p>
</li>
<li><p>unshift()：从头部添加一个值</p>
</li>
<li><p>pop()：在末尾减去一个值</p>
</li>
<li><p>push()：在末尾加上一个值</p>
</li>
<li><p>reverse()：反转数组值的顺序</p>
</li>
<li><p>sort()：升序排序数组项。</p>
<p>注意：数值5&gt;10 但是在字符串比较时，“10”在“5”前面，于是数组的顺序就被修改了。</p>
<p>sort()方法可以接收一个比函数作为参数，以便我们指定哪个值在前面。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value1&lt;value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1&gt;value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);<span class="comment">//则是按小到大排序</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>concat()：这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组。</p>
</li>
<li><p>slice()</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、colors.slice(<span class="number">1</span>)<span class="comment">//从位置1开始复制，到结束</span></span><br><span class="line"><span class="number">2</span>、colors.slice(<span class="number">1</span>,<span class="number">4</span>)<span class="comment">//从位置1开始复制，包含四项的新数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>splice</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">splice(<span class="number">0</span>,<span class="number">2</span>)<span class="comment">//删除数组前两项</span></span><br><span class="line">splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"red"</span>,<span class="string">"green"</span>)<span class="comment">//从数组位置2开始插入字符串“red”和“green”</span></span><br><span class="line">splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"red"</span>,<span class="string">"green"</span>)<span class="comment">//会删除当前数组位置2的项，然后从位置2开始插入字符串。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h6><ul>
<li>indexOf()和lastIndexOd()：接收两个参数：要查找的参数和（可选）查找起点的索引。</li>
<li>indexOf：从数组开头(位置0)开始向后查找。</li>
<li>lastIndexOf：从数组末尾开始向前查找。</li>
<li>这两个方法都返回要查找的项在数组中的位置，或者在没有找到的情况下返回-1.<strong>在比较第一个参数与数组中每一项时，会用全等操作符。</strong></li>
</ul>
<h6 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h6><p>每个方法都要接收两个参数：要在每一项上运行的函数和（可选）运行该函数的作用域对象。传入这些方法的函数会接收三个参数：数组项的值、该项在数组中的位置、数组对象本身。</p>
<ul>
<li><p>every()</p>
</li>
<li><p>some()</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item&gt;<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">alert(everyResult)<span class="comment">//false,要全部符合条件才会返回true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item&gt;<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">alert(someResult)<span class="comment">//true，只要只有一个符合条件就会返回true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter()：利用指定的函数，确定是否在返回的数组中包含某一项</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item&gt;<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult);<span class="comment">//[3,4,5,4,3];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>map()：可以返回在原始对象上进行操作（相乘等等）的数组。</p>
</li>
<li><p>forEach()：没有返回值，类似于for循环。</p>
</li>
</ul>
<h6 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h6><ul>
<li><p>reduce()和reduceRight()：迭代数组的所有项，然后构建一个最终返回的值。其中，reduce方法从数组第一项开始，逐个遍历到最后，而reduceRight()则从数组最后一项开始，向前遍历到第一项。</p>
</li>
<li><p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值。传入的函数接收四个参数：前一个值，当前值，项的索引，数组对象。</p>
<p>eg：利用reduce求和</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev+cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum);</span><br><span class="line"><span class="comment">//第一次执行回调函数，pre是1，cur是2，第二次执行，pre是3（1+2的值），cur是3（第三项的值）。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/10/day3/" data-id="cjyegcsf1000ch0vczrt3oim2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/20/day12/">day12</a>
          </li>
        
          <li>
            <a href="/2019/07/18/day11/">day11</a>
          </li>
        
          <li>
            <a href="/2019/07/17/day10/">day10</a>
          </li>
        
          <li>
            <a href="/2019/07/17/day9/">day9</a>
          </li>
        
          <li>
            <a href="/2019/07/16/day8/">day8</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>