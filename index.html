<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-day4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/11/day4/" class="article-date">
  <time datetime="2019-07-11T01:01:15.000Z" itemprop="datePublished">2019-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/11/day4/">day4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h5><p>1、调用Date构造函数而不必传递参数情况下，新创建的对象自动获得当前日期和时间。</p>
<p>2、Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。</p>
<p>3、和其他引用类型一样，Date重写了toString(),toLocaleString,valueOf()方法。</p>
<ul>
<li>toLocaleString：按照与浏览器设置的地区相适应的格式返回日期和时间</li>
<li>toString：返回带有时区信息的日期和时间，使劲按一般以军用时间（小时范围0-23）</li>
<li>valueOf：不返回字符串，而是返回日期的毫秒数。因此可以用比较操作符来比较日期。使用alert（）时，后台会自动使用valueOf。</li>
</ul>
<p>4、toUTCString()：以特定于实现的格式完整的UTC日期。（推荐使用）</p>
<h5 id="RexExp类型"><a href="#RexExp类型" class="headerlink" title="RexExp类型"></a>RexExp类型</h5><p>ECMAScript通过RegExp类型来支持正则表达式。</p>
<p>eg：正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags;<span class="comment">//类似Perl语法</span></span><br></pre></td></tr></table></figure>

<p>pattern部分可带有一个或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。</p>
<ul>
<li>g：表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止。</li>
<li>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串 的大小写。</li>
<li>m：表示多行（multiple）模式，即在到达一行文本末尾时还会继续查找下一行是否存在与模式匹配的项。</li>
</ul>
<p>1、元字符：（   {   [    \     ^    $   |    )  ?    *    +    .    ]   }   </p>
<p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对他们进行转义。</p>
<p>2、由于RegExp构造函数的模式参数是字符串，所以在某些情况下，要对字符串进行双重转义。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;<span class="comment">//表示匹配第一个[bc]at，不分大小写</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>,<span class="string">"i"</span>)<span class="comment">//双重转义。</span></span><br><span class="line"><span class="comment">//pattern1和pattern2相同，只不过是2是构造函数构建的。</span></span><br></pre></td></tr></table></figure>

<h6 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h6><ul>
<li><p>global：布尔值，表示是否设置了g标志</p>
</li>
<li><p>ignoreCase：布尔值，表示是否设置了i标志</p>
</li>
<li><p>lastIndex：整数，表示开始搜下下一个匹配项的字符位置，从0算起。</p>
</li>
<li><p>multiline：布尔值，表示是否设置了m标志</p>
</li>
<li><p>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>,<span class="string">"i"</span>);</span><br><span class="line">alert(pattern2.global);<span class="comment">//false</span></span><br><span class="line">alert(pattern2.ignoreCase);<span class="comment">//true</span></span><br><span class="line">alert(pattern2.multiline);<span class="comment">//false</span></span><br><span class="line">alert(pattern2.lastIndex);<span class="comment">//0</span></span><br><span class="line">alert(pattern2.source);<span class="comment">//"\[bc\]at"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h6><ul>
<li><p>exec()方法：用于检索字符串中的正则表达式的匹配，返回值是一个数组，但该数组的内容和正则对象是否是全局匹配有很大关系。</p>
<p>1、没有g修饰符：在非全局匹配模式下，此函数的作用和match()函数一样，只能够在字符串中匹配一次，如果没有找到匹配的字符串，那么返回null，否则返回一个数组，<strong>数组的第0个元素存储的是匹配字符串，第1个元素存放的是第一个子表达式（正则中用（）包住的部分）匹配的字符串，以此类推。</strong>同时该数组包括两个对象属性，index属性表明匹配字符串的其实字符在要匹配的完整字符串中的位置，input属性声明的是对要匹配的完整字符串的引用。</p>
<p>2、有g修饰符：在全局匹配模式下，此函数返回值同样是一个数组，并且也只能匹配一次，不过此时，此函数一般会和lastIndex属性匹配使用，此函数会在lastIndex属性指定的字符处开始检索字符串，当exec()找到与表达式相匹配的字符串时，在匹配后，它将<strong>lastIndex属性设置为匹配字符串的最后一个字符的下一个位置</strong>。可以丰富调用exec()函数遍历字符串中所有的匹配，知道再也找不到匹配的文本，它将返回null，并将lastIndex属性重置为0.</p>
<p>注：数组的内容结构和没有g修饰符完全相同。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"abbb34eftab0modabbbbbbb6"</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a(b)+(\d+)/i</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.match(reg);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(arr[i]);</span><br><span class="line">    <span class="comment">//如果是g全局，那么返回所有匹配[abbb34,ab0,abbbbbbb6]</span></span><br><span class="line">    <span class="comment">//如果没有g全局，那么返回arr[0],后面则是字表达式的捕获。[abbb34,b,34]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h5><ul>
<li><p>函数声明：解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）。</p>
</li>
<li><p>函数表达式：必须等到解析器执行到它所在的代码行，才会真正被解析。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样可以使用。</span></span><br><span class="line"></span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会出错。</span></span><br></pre></td></tr></table></figure>

<p>原因：第一个是函数声明，在代码开始执行前，解析器就通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍声明函数并将它们放在源代码树的顶部。</p>
<p>而第二个不是</p>
</li>
</ul>
<h6 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h6><ul>
<li>arguments</li>
<li>callee：是arguments的一个属性，该属性是一个指针，值向拥有这个arguments对象的函数。不能为这个属性赋值，否则会发生错误。</li>
<li>this：函数执行的环境对象——或者可以说是this值（当在页面的全局作用域中调用函数时，this对象引用的就是window）</li>
</ul>
<p>注意：函数的名字仅仅是一个包含指针的变量。</p>
<h6 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h6><ul>
<li><p>属性</p>
<ul>
<li><p>length：函数希望接收的命名参数的个数。</p>
</li>
<li><p>prototype（原型）：为一个特定类声明通用的变量或者函数。</p>
<p><a href="https://www.cnblogs.com/dengpeng1004/p/5317245.html" target="_blank" rel="noopener">博客</a></p>
</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li>apply()：接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组。</li>
<li>call()：</li>
</ul>
<p>作用：可以扩充函数赖以运行的作用域</p>
</li>
</ul>
<h6 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h6><p>注意：使用new调用基本包装类型的构造函数，和直接调用同名的转型函数是不一样的。</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value);<span class="comment">//转型函数</span></span><br><span class="line">alert (<span class="keyword">typeof</span> number);<span class="comment">//"number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value);<span class="comment">//构造函数</span></span><br><span class="line">alert (<span class="keyword">typeof</span> obj);<span class="comment">//"object"</span></span><br><span class="line"><span class="comment">//在这个例子中，number保存的是基本类型的值，而obj保存的是Number的实例。</span></span><br></pre></td></tr></table></figure>

<p>自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立刻被销毁。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line">s1.color = <span class="string">"red"</span>;</span><br><span class="line">alert(s1.color)<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>第二行代试图为字符串s1添加一个属性，但是，当第三行代码再次访问s1时，其color属性不见了。原因是第二行创建的String对象，在执行第三行代码时已经被销毁了。第三行代码又创建了自己的String对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/11/day4/" data-id="cjxypa0is0001oovcn6btkcrb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/10/day3/" class="article-date">
  <time datetime="2019-07-10T01:15:21.000Z" itemprop="datePublished">2019-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/day3/">day3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><h5 id="1、for-in-语句"><a href="#1、for-in-语句" class="headerlink" title="1、for in 语句"></a>1、for in 语句</h5><p>概念：遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量 <span class="keyword">in</span> 对象)</span><br><span class="line">    <span class="comment">//“变量”用来指定变量，指定的变量可以是数组元素，也可以是对象的属性。</span></span><br><span class="line">&#123;</span><br><span class="line">    在此执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、label-语句"><a href="#2、label-语句" class="headerlink" title="2、label 语句"></a>2、label 语句</h5><p>使用label语句可以在代码中添加标签，以便将来使用。可以由break或continue语句引用。</p>
<h5 id="3、switch语句"><a href="#3、switch语句" class="headerlink" title="3、switch语句"></a>3、switch语句</h5><p>注意：switch语句在比较值的时候，用的是全等操作符，因此不会发生类型转换。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="1、参数"><a href="#1、参数" class="headerlink" title="1、参数"></a>1、参数</h5><ul>
<li>命名的参数只提供便利，但不是必需。</li>
<li>ECMAScript函数不介意传递进来的参数多少个，什么类型。因为传进来的参数用一个数组来表示。在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。</li>
<li>arguments对象只是与数组类似（但不是数组），可以用方括号语法访问它的每一个元素，可以使用length属性确定传递进来几个参数。但是没有数组的其他特性。</li>
</ul>
<h5 id="2、不能重载"><a href="#2、不能重载" class="headerlink" title="2、不能重载"></a>2、不能重载</h5><p>重载：用同样的方法名，传递不同的参数，实现不同的目的。</p>
<ul>
<li>在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。</li>
</ul>
<hr>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量包含两种不同数据类型的值：</p>
<ul>
<li><p>基本类型值：简单的数据段。：五种基本数据类型，按值访问。（可给基本类型添加属性，但在下次访问该属性时，发现该属性会不见。）</p>
</li>
<li><p>引用类型值：可能由多个值构成的对象。可以动态的添加属性，以便将来使用。（添加属性时，如果对象不被销毁或者这个属性不被删除，则这个属性将一只存在。）<strong>值保存在内存中。</strong></p>
<p><strong>注意：按引用访问：在js中不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在堆内存中的地址，再按照这个地址去获得这个对象的值。</strong></p>
</li>
</ul>
<h5 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h5><ul>
<li>基本类型值：如果从一个变量向另一个变量复制基本类型的值时，会在变量对象上创建一个新，然后把该值复制到为新变量分配的位置上。<strong>复制与被复制的变量是完全独立的，这两个变量可以参与任何操作而不会相互影响。</strong></li>
<li>引用类型值：同样会将存储在变量对象中的值复制一份放到新变量分配的空间中，不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。<strong>复制结束后，两个变量实际上将引用同一个对象。</strong></li>
</ul>
<h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>ECMASCript中所有函数的参数都是按值传递的。</p>
<h5 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h5><p>instanceof操作符，可以怕判断某个值是什么类型的对象</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//person是object吗</span></span><br><span class="line">alert(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line"><span class="comment">//如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false</span></span><br></pre></td></tr></table></figure>

<h4 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h4><h5 id="1、作用域"><a href="#1、作用域" class="headerlink" title="1、作用域"></a>1、作用域</h5><ul>
<li><p>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p>
</li>
<li><p>作用：提高了程序的逻辑的局部性，增强程序的可靠性，以及避免命名冲突，为代码的模块化开发提供便利。</p>
</li>
</ul>
<h5 id="2、作用域链"><a href="#2、作用域链" class="headerlink" title="2、作用域链"></a>2、作用域链</h5><p>每个函数都有自己的执行环境，包含当前环境的变量访问关系，与之相关联的就是“变量对象”，如果是当前函数的变量对象，也可以称之为“活动对象”。该对象包含了：当前函数可访问的变量及函数。</p>
<p>eg </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">"test"</span>;</span><br><span class="line">    <span class="comment">//变量对象中包含：命名函数fn变量，参数name，内部变量test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：变量对象是不可访问的，只提供后台引擎编译执行使用，当定义由多个变量对象嵌套，这些变量对象就组成了作用域链。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">super</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"super"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">"sub"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子构成的作用域链为：</p>
<p>全局变量对象window——&gt; 变量对象super——&gt; 活动对象sub</p>
<p>变量访问原则是，根据作用域前端往上搜索，如果提前搜索到变量，就停止搜索，例如上面的例子中，name变量的值是sub，因为其再最前端的变量对象中就已经定义了，则不会往上继续检索。</p>
<h5 id="3、延长作用域"><a href="#3、延长作用域" class="headerlink" title="3、延长作用域"></a>3、延长作用域</h5><p>1、try-catch语句的catch块</p>
<p>2、with语句(不用)</p>
<h5 id="4、执行环境只与函数的声明及定义位置有关"><a href="#4、执行环境只与函数的声明及定义位置有关" class="headerlink" title="4、执行环境只与函数的声明及定义位置有关"></a>4、执行环境只与函数的声明及定义位置有关</h5><p>当一个函数定义后，其执行环境与作用域链就已经确定了，不会因为执行位置改变而改变。</p>
<hr>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="1、object类型"><a href="#1、object类型" class="headerlink" title="1、object类型"></a>1、object类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person =&#123;&#125; <span class="comment">//相当于 new Object();</span></span><br><span class="line"><span class="comment">//访问对象的属性</span></span><br><span class="line">person[<span class="string">"name"</span>];</span><br><span class="line">person.name;</span><br><span class="line">person[<span class="string">"first name"</span>]</span><br><span class="line"><span class="comment">//由于first name含有空格，用点访问会出错，可以用方括号表示来访问。</span></span><br><span class="line"><span class="comment">//通常情况下，除非必须用变量来访问属性，否则建议用点表示法。</span></span><br></pre></td></tr></table></figure>

<h5 id="2、Array类型"><a href="#2、Array类型" class="headerlink" title="2、Array类型"></a>2、Array类型</h5><ul>
<li>数组的length不仅仅只读，还可以进行修改，若数组含有三个元素，将length改成2，则最后一个元素将会被移除。</li>
</ul>
<h6 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h6><ul>
<li>instanceof操作符的问题在于，它假定只有一个全局执行环境，如果一个网页中包含多个框架，那实际上存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数</li>
<li>为了解决上述问题，新增了Array.isArray()方法，这个方法目的是最终确定某个值是不是数组，而不管它在在哪个全局执行环境中创建的。</li>
</ul>
<h6 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h6><ul>
<li><p>所有对象都有toLocaleString()、toString()、valueOf()方法。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">alert(colors.toString());<span class="comment">//red,blue,green</span></span><br><span class="line">alert(colors.valueOf());<span class="comment">//red,blue,green</span></span><br><span class="line">alert(colors);<span class="comment">//red,blue,green</span></span><br></pre></td></tr></table></figure>

<p>显式的调用toString()方法，每个值的字符串表示拼接成了一个字符串，中间要用逗号分隔。</p>
<p>由于alert()要接受字符串参数，所以它在后台调用toString()方法，由此会得到与直接调用toString()方法相同的结果。</p>
</li>
<li><p>join()方法，可以用不同的分隔符来构建这个字符串。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,<span class="string">"blue"</span>];</span><br><span class="line">colors.join(<span class="string">"||"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果数组中某一项的值是null或者undefined，那么该值在join(),toLocaleString(),toString(),valueOf()方法返回的结果中以空字符串表示。</p>
</li>
</ul>
<h6 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h6><ul>
<li><p>shift()：从头部删除一个值</p>
</li>
<li><p>unshift()：从头部添加一个值</p>
</li>
<li><p>pop()：在末尾减去一个值</p>
</li>
<li><p>push()：在末尾加上一个值</p>
</li>
<li><p>reverse()：反转数组值的顺序</p>
</li>
<li><p>sort()：升序排序数组项。</p>
<p>注意：数值5&gt;10 但是在字符串比较时，“10”在“5”前面，于是数组的顺序就被修改了。</p>
<p>sort()方法可以接收一个比函数作为参数，以便我们指定哪个值在前面。</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value1&lt;value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1&gt;value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);<span class="comment">//则是按小到大排序</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>concat()：这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组。</p>
</li>
<li><p>slice()</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、colors.slice(<span class="number">1</span>)<span class="comment">//从位置1开始复制，到结束</span></span><br><span class="line"><span class="number">2</span>、colors.slice(<span class="number">1</span>,<span class="number">4</span>)<span class="comment">//从位置1开始复制，包含四项的新数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>splice</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">splice(<span class="number">0</span>,<span class="number">2</span>)<span class="comment">//删除数组前两项</span></span><br><span class="line">splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">"red"</span>,<span class="string">"green"</span>)<span class="comment">//从数组位置2开始插入字符串“red”和“green”</span></span><br><span class="line">splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"red"</span>,<span class="string">"green"</span>)<span class="comment">//会删除当前数组位置2的项，然后从位置2开始插入字符串。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h6><ul>
<li>indexOf()和lastIndexOd()：接收两个参数：要查找的参数和（可选）查找起点的索引。</li>
<li>indexOf：从数组开头(位置0)开始向后查找。</li>
<li>lastIndexOf：从数组末尾开始向前查找。</li>
<li>这两个方法都返回要查找的项在数组中的位置，或者在没有找到的情况下返回-1.<strong>在比较第一个参数与数组中每一项时，会用全等操作符。</strong></li>
</ul>
<h6 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h6><p>每个方法都要接收两个参数：要在每一项上运行的函数和（可选）运行该函数的作用域对象。传入这些方法的函数会接收三个参数：数组项的值、该项在数组中的位置、数组对象本身。</p>
<ul>
<li><p>every()</p>
</li>
<li><p>some()</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item&gt;<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">alert(everyResult)<span class="comment">//false,要全部符合条件才会返回true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item&gt;<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">alert(someResult)<span class="comment">//true，只要只有一个符合条件就会返回true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter()：利用指定的函数，确定是否在返回的数组中包含某一项</p>
<p>eg</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item&gt;<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult);<span class="comment">//[3,4,5,4,3];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>map()：可以返回在原始对象上进行操作（相乘等等）的数组。</p>
</li>
<li><p>forEach()：没有返回值，类似于for循环。</p>
</li>
</ul>
<h6 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h6><ul>
<li><p>reduce()和reduceRight()：迭代数组的所有项，然后构建一个最终返回的值。其中，reduce方法从数组第一项开始，逐个遍历到最后，而reduceRight()则从数组最后一项开始，向前遍历到第一项。</p>
</li>
<li><p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值。传入的函数接收四个参数：前一个值，当前值，项的索引，数组对象。</p>
<p>eg：利用reduce求和</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev+cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum);</span><br><span class="line"><span class="comment">//第一次执行回调函数，pre是1，cur是2，第二次执行，pre是3（1+2的值），cur是3（第三项的值）。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/10/day3/" data-id="cjxypa0j80002oovcjjg8xl7a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/09/day2/" class="article-date">
  <time datetime="2019-07-09T01:26:29.000Z" itemprop="datePublished">2019-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/09/day2/">day2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="在html中使用JavaScript"><a href="#在html中使用JavaScript" class="headerlink" title="在html中使用JavaScript"></a>在html中使用JavaScript</h4><h5 id="1、-lt-script-gt-元素嵌入代码"><a href="#1、-lt-script-gt-元素嵌入代码" class="headerlink" title="1、&lt;script&gt;元素嵌入代码"></a>1、<code>&lt;script&gt;</code>元素嵌入代码</h5><ul>
<li><p>包含在<code>&lt;script&gt;</code>元素内部的JavaScript代码将从上至下以此解释。在解释器对<code>&lt;script&gt;</code>元素内部所有代码求值完毕之前，页面中的其余内容都不会被浏览器加载或显示。</p>
</li>
<li><p>在使用<code>&lt;script&gt;</code>嵌入JavaScript代码时，不要在代码任何地方出现 “&lt;’/script&gt;”字符串</p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> 	alert(<span class="string">"&lt;/script&gt;"</span>);</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就会出现错误，因为按照解析嵌入式代码的规则，当浏览器遇到字符串<code>&lt;/script&gt;</code>时，会认为那是结束标签。需要通过转义字符“\”解决这个问题。</p>
</li>
</ul>
<h5 id="2、-lt-script-gt-标签引入外部脚本文件"><a href="#2、-lt-script-gt-标签引入外部脚本文件" class="headerlink" title="2、&lt;script&gt;标签引入外部脚本文件"></a>2、<code>&lt;script&gt;</code>标签引入外部脚本文件</h5><ul>
<li>带src属性的<code>&lt;script&gt;</code>元素不应该在其<code>&lt;script&gt;&lt;/script&gt;</code>标签里再包含JavaScript代码。因为如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码则会被忽略。</li>
<li>src属性可以包含来自外部域的JavaScript文件。</li>
<li>无论如何包含代码，只要不存在defer和async属性，浏览器都会按照<code>&lt;script&gt;</code>元素在页面中出现的先后顺序对他们一次进行解析。（第一个script标签解析后，第二个第三个…一次进行）</li>
</ul>
<h5 id="3、标签的位置"><a href="#3、标签的位置" class="headerlink" title="3、标签的位置"></a>3、标签的位置</h5><ul>
<li>把<code>&lt;script&gt;</code>标签放在<code>&lt;head&gt;</code>元素中，这种做法的目的是把所有外部文件的引用都放在同一个地方。但是在<code>&lt;head&gt;</code>元素中包含JavaScript文件，意味着必须等到所有的JavaScript代码都被下载、解析和执行完成后，才能呈现页面的内容。对于需要很多JavaScript代码的页面来说，会导致浏览器呈现页面时出现明显的延迟，而延迟期间浏览器的窗口将一片空白。</li>
<li>为了避免以上所说的问题，一般将JavaScript引用在<code>&lt;body&gt;</code>元素中页面内容的后面。</li>
</ul>
<h5 id="4、延迟脚本"><a href="#4、延迟脚本" class="headerlink" title="4、延迟脚本"></a>4、延迟脚本</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">"defer"</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>=<span class="string">"defer"</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>defer属性表明脚本在执行时不会影响页面的构造，换句话说，脚本会被延迟到整个页面都解析完毕之后再运行。</p>
<ul>
<li><p>在这个例子中，虽然把<code>&lt;script&gt;</code>元素放在<code>&lt;head&gt;</code>元素中，但其包含的脚本将延迟到遇到<code>&lt;/html&gt;</code>标签后再执行。 </p>
</li>
<li><p>html5规范要求脚本按照他们出现的先后顺序执行，所以第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded事件执行。但在现实中，延迟脚本不一定会按照顺序执行，也不一定会在DOMContentLoaded事件触发之前执行。因此，最好只包含一个延迟脚本。</p>
</li>
<li><p>当初始的html文档被完全加载和解析完成之后，DOMContentLoaded事件被触发。</p>
</li>
</ul>
<h5 id="5、异步脚本"><a href="#5、异步脚本" class="headerlink" title="5、异步脚本"></a>5、异步脚本</h5><ul>
<li>与defer类似，async只使用于外部脚本文件，并告诉浏览器立即下载文件。</li>
<li>与defer不同的是，标记为async的脚本并不保证按照指定他们的先后顺序执行。</li>
<li>指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。<strong>因此，建议异步脚本不要在加载期间修改DOM。</strong></li>
</ul>
<h5 id="6、noscript元素"><a href="#6、noscript元素" class="headerlink" title="6、noscript元素"></a>6、noscript元素</h5><p>包含在<code>&lt;noscript&gt;</code>元素中的内容只有在下列情况下才会显示出来：</p>
<ul>
<li>浏览器不支持脚本。</li>
<li>浏览器支持脚本，但是脚本被禁用。</li>
</ul>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="1、用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这么变量在函数退出后就会被销毁。"><a href="#1、用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这么变量在函数退出后就会被销毁。" class="headerlink" title="1、用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这么变量在函数退出后就会被销毁。"></a>1、用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这么变量在函数退出后就会被销毁。</h5><h5 id="2、typeof操作符"><a href="#2、typeof操作符" class="headerlink" title="2、typeof操作符"></a>2、typeof操作符</h5><p>可能会返回下列某个字符串</p>
<ul>
<li><p>“undefined”——未定义</p>
<ul>
<li>使用var声明变量但是并未对齐初始化，这个变量就是undefined。</li>
</ul>
</li>
<li><p>“Boolean”——布尔值</p>
<ul>
<li><p>true和false与数字值不是一回事，true不一定等于1，false不一定等于0。</p>
</li>
<li><p>Boolean类型的字面值true和false是区分大小写的，True和False都不是Boolean值，只是标识符。</p>
</li>
<li><p>虽然Boolean类型的字面值只有两个，但是ECMAScript所有类型的值都有与这两个Boolean值等价的值。要将一个值转换成对应的Boolean值，可以调用转型函数Boolean();</p>
<ul>
<li>undefined类型的n/a(not application/不适用)转成true。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>“string”——字符串</p>
<ul>
<li><p>字符串是不可变的，也就是说，字符串一旦创建，他们的值就不可以改变。</p>
</li>
<li><p>toString()：返回字符串，可传递一个参数，如 </p>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">num.toString();<span class="comment">//"10"</span></span><br><span class="line">num.toString(<span class="number">2</span>);<span class="comment">//"1010"</span></span><br><span class="line">num.toString(<span class="number">8</span>);<span class="comment">//"12"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>String()：null和undefined没有toString方法，所以String()返回了这两个值的字面量。</p>
</li>
</ul>
</li>
<li><p>“number”——数值</p>
<ul>
<li><p>八进制：第一位必须是0，然后是八进制数字序列（0-7），如果字面值超过了７，那么前导零将会被忽略，后面的值将被当成十进制解析</p>
<p>eg：079 //无效八进制——解析为79.</p>
</li>
<li><p>十六进制：前两位必须是0x</p>
</li>
<li><p>isFinite()函数：如果number是NaN，或者是正、负无穷大的数，则返回false。</p>
</li>
<li><p>NaN（not a number）是一个特殊的数值，注意NaN！=NaN。</p>
<ul>
<li>alert(isNaN(“10”)) ;//true 字符串“10”可以转成数值。</li>
<li>alert(isNaN(“blue”)); //false 字符串“blue”不可以转成数值。</li>
</ul>
</li>
<li><p>数值转换</p>
<ul>
<li><p>Number() </p>
<ul>
<li>null——返回0</li>
<li>undefined——返回NaN</li>
<li>浮点数——浮点数</li>
<li>字符串<ul>
<li>若字符串为为”011”,则会变成11（前导零被忽略了）</li>
<li>若有有效的十六进制，则转换成对应大小的十进制数值</li>
<li>若字符串是空的，则转成0</li>
<li><strong>若包括除数字外还有其他字符，则转成NaN</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>parseInt()</p>
<ul>
<li><p>小数——整数（因为小数点不是有效数字字符）</p>
</li>
<li><p>null——NaN</p>
</li>
<li><p>在ECMAScript 5 Javascript引擎中，parseInt()不具有解析八进制能力，前导零被认为无效。为消除困惑，可为该函数提供第二个参数。parseInt(“70”,8),则指定数值按照八进制解析。</p>
<p>注意：如果第一个字符不是数字数值或者符号，会忽略前面的空格，知道找到第一个非空格字符。如果第一个字符不是数字或者符号，则会返回NaN，知道解析所有字符或者遇到非数字字符。</p>
<p><img src="/.com//3.jpg" alt></p>
<p><img src="/.com//4.jpg" alt></p>
<p><img src="/.com//1.jpg" alt></p>
<p><img src="/.com//2.jpg" alt></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>“object”——对象或null（特殊值null被认为是一个空对象指针）</p>
<p>对象：一组数据和功能的集合。</p>
</li>
<li><p>“function”——函数</p>
</li>
</ul>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"aaa"</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> message);<span class="comment">//"string"</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(message));<span class="comment">//“string”</span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="number">100</span>);<span class="comment">//"number"</span></span><br></pre></td></tr></table></figure>

<p>typeof操作符可以是变量，也可以是数值字面量。typeof是一个操作符而不是函数，因此例子中圆括号可以使用，但不是必须的。</p>
<h5 id="3、操作符"><a href="#3、操作符" class="headerlink" title="3、操作符"></a>3、操作符</h5><h5 id="乘法操作符"><a href="#乘法操作符" class="headerlink" title="乘法操作符"></a>乘法操作符</h5><ul>
<li>如果有一个操作数是NaN，则结果是NaN。</li>
<li>如果是infinity与0相乘，结果 NaN。</li>
<li>infinity与非零相乘，结果是infinity或-infinity。</li>
<li>如果有一个操作数不是数值，则在后台调用number()将其转换成数值，再应用上面的规则。</li>
</ul>
<h5 id="除法操作符"><a href="#除法操作符" class="headerlink" title="除法操作符"></a>除法操作符</h5><ul>
<li>如果零被整除，其结果是NaN</li>
</ul>
<h5 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">"23"</span>&lt;<span class="string">"3"</span><span class="comment">//true</span></span><br><span class="line">因为两个操作数都是字符串，而字符串比较的是字符编码。（“<span class="number">2</span>”的字符编码是<span class="number">50</span>，“<span class="number">3</span>”的字符编码是<span class="number">51</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"23"</span>&lt;<span class="number">3</span>;<span class="comment">//false</span></span><br><span class="line">这是，字符串“<span class="number">23</span>”会被转换成数值<span class="number">23</span>，然后再与<span class="number">3</span>进行比较。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"a"</span>&lt;<span class="number">3</span> <span class="comment">//false</span></span><br><span class="line">由于字符<span class="string">"a"</span>不能转换成合理的数值，因此被转换成<span class="literal">NaN</span>.根据规则，任何操作数与<span class="literal">NaN</span>进行关系比较都是<span class="literal">false</span>。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/09/day2/" data-id="cjxypa0jl0004oovclkl7o0l9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-day1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/day1/" class="article-date">
  <time datetime="2019-07-08T09:44:14.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/day1/">day1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>### </p>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><ul>
<li><p>hexo new “title”：新建标题为 title的文章。</p>
</li>
<li><p>hexo g ： 生成网站静态文件到默认设置的public文件夹</p>
<ul>
<li>便于查看网站生成的静态文件或者手动部署网站。</li>
<li>hexo g 是hexo generate的缩写。</li>
</ul>
</li>
<li><p>hexo s ：启用本地服务器，用于预览主题。默认地址为 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p>
<ul>
<li>hexo s 是hexo server 的缩写，命令效果一致。</li>
<li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可。</li>
</ul>
</li>
<li><p>hexo d ：自动生成网站静态文件，并部署到设定的仓库</p>
<ul>
<li>hexo d 是hexo deploy的缩写。</li>
</ul>
</li>
</ul>
<h3 id="git流程"><a href="#git流程" class="headerlink" title="git流程"></a>git流程</h3><p>1、克隆仓库</p>
<p>git clone XXX</p>
<p>git init</p>
<p>2、先获取远程master分支的最新代码</p>
<p>git checkout master</p>
<p>git pull origin master</p>
<p>3、创建分支</p>
<p>git branch test</p>
<p>4、切换分支</p>
<p>git checkout test</p>
<p>（3、4可合成 git checkout -b test）</p>
<p>5、在完成步骤2，3后，就可以继续自己的工作（敲代码）</p>
<p>6、完成工作后，就可以提交到自己的工作分支test</p>
<p>git add .   （这个指令是指我们在工作区对文件做的修改放入暂存区，之后可以继续对该文件进行修改，但暂存区里面保存了该文件上一次放进去的样子）</p>
<p>git commit -m “ 这里是解释 “  （将暂存区的文件提交到本地版本库）</p>
<p><strong>1-6步骤，对git的操作都只是在本地进行，需要对代码的修改推到远程仓库，其他人才能看到修改后的代码</strong></p>
<p>7、git push origin test</p>
<p>8、此时该分支的代码还不在master分支中，避免merge失败，先将master分支上最新的代码 marge到当前分支。</p>
<p>git pull –rebase origin master</p>
<p>（如果有错误题是，则打开冲突文件，修改冲突</p>
<p>git status：查看有冲突的文件</p>
<p>调整好冲突文件后，git add .</p>
<p>）</p>
<p>9、git add .</p>
<p>git rebase –continue</p>
<p>git push origin test</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/08/day1/" data-id="cjxypa0i30000oovcxx6yuv9o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/hello-world/" class="article-date">
  <time datetime="2019-07-08T01:31:33.444Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/08/hello-world/" data-id="cjxypa0ja0003oovczxpb79qe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/11/day4/">day4</a>
          </li>
        
          <li>
            <a href="/2019/07/10/day3/">day3</a>
          </li>
        
          <li>
            <a href="/2019/07/09/day2/">day2</a>
          </li>
        
          <li>
            <a href="/2019/07/08/day1/">day1</a>
          </li>
        
          <li>
            <a href="/2019/07/08/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>